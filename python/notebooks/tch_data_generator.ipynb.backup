{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Texas Children's Hospital Patient 360 PoC - Data Generator Notebook\n",
        "\n",
        "This notebook generates comprehensive, realistic synthetic healthcare data for the Texas Children's Hospital Patient 360 PoC demonstration, including both structured and unstructured data sources.\n",
        "\n",
        "## Execution Parameters\n",
        "- `data_size`: Size of dataset to generate (small/medium/large)\n",
        "- `num_patients`: Number of patients (overrides data_size if provided)\n",
        "- `encounters_per_patient`: Average encounters per patient (default: 5)\n",
        "- `compress_files`: Whether to compress output files (default: true)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Import required packages\n",
        "import os\n",
        "import sys\n",
        "import json\n",
        "import csv\n",
        "import gzip\n",
        "import shutil\n",
        "import random\n",
        "import uuid\n",
        "from datetime import datetime, timedelta, date\n",
        "from typing import Dict, List, Optional, Tuple\n",
        "from pathlib import Path\n",
        "\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "from faker import Faker\n",
        "from snowflake.snowpark.context import get_active_session\n",
        "\n",
        "# Get Snowflake session\n",
        "session = get_active_session()\n",
        "\n",
        "print(f\"Connected to Snowflake as {session.get_current_user()}\")\n",
        "print(f\"Database: {session.get_current_database()}\")\n",
        "print(f\"Schema: {session.get_current_schema()}\")\n",
        "print(f\"Warehouse: {session.get_current_warehouse()}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Get execution parameters from notebook arguments\n",
        "# When using EXECUTE NOTEBOOK, arguments are passed as strings and accessible via sys.argv\n",
        "# Example: EXECUTE NOTEBOOK MY_NOTEBOOK('data_size=small', 'encounters_per_patient=10')\n",
        "\n",
        "# Default values\n",
        "DATA_SIZE = 'medium'\n",
        "NUM_PATIENTS = None\n",
        "ENCOUNTERS_PER_PATIENT = 5\n",
        "COMPRESS_FILES = True\n",
        "\n",
        "# Parse arguments if provided\n",
        "if hasattr(sys, 'argv') and len(sys.argv) > 0:\n",
        "    print(f\"Arguments received: {sys.argv}\")\n",
        "    \n",
        "    # Parse key=value arguments\n",
        "    for arg in sys.argv:\n",
        "        if isinstance(arg, str) and '=' in arg:\n",
        "            key, value = arg.split('=', 1)\n",
        "            if key == 'data_size':\n",
        "                DATA_SIZE = value\n",
        "            elif key == 'num_patients':\n",
        "                NUM_PATIENTS = int(value)\n",
        "            elif key == 'encounters_per_patient':\n",
        "                ENCOUNTERS_PER_PATIENT = int(value)\n",
        "            elif key == 'compress_files':\n",
        "                COMPRESS_FILES = value.lower() != 'false'\n",
        "\n",
        "# Determine number of patients based on size or explicit count\n",
        "if NUM_PATIENTS is None:\n",
        "    size_map = {\n",
        "        'small': 1000,\n",
        "        'medium': 5000,\n",
        "        'large': 25000\n",
        "    }\n",
        "    NUM_PATIENTS = size_map.get(DATA_SIZE, 5000)\n",
        "\n",
        "print(f\"\\nConfiguration:\")\n",
        "print(f\"  Data size: {DATA_SIZE}\")\n",
        "print(f\"  Number of patients: {NUM_PATIENTS:,}\")\n",
        "print(f\"  Encounters per patient: {ENCOUNTERS_PER_PATIENT}\")\n",
        "print(f\"  Compress files: {COMPRESS_FILES}\")\n",
        "print(f\"  Expected total encounters: ~{NUM_PATIENTS * ENCOUNTERS_PER_PATIENT:,}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Setup output paths in Snowflake internal stage\n",
        "# We'll use the existing PATIENT_DATA_STAGE and UNSTRUCTURED_DATA_STAGE\n",
        "\n",
        "STRUCTURED_STAGE = '@TCH_PATIENT_360_POC.RAW_DATA.PATIENT_DATA_STAGE'\n",
        "UNSTRUCTURED_STAGE = '@TCH_PATIENT_360_POC.RAW_DATA.UNSTRUCTURED_DATA_STAGE'\n",
        "\n",
        "# Local temporary directory for file generation\n",
        "TEMP_DIR = Path('/tmp/tch_data_generation')\n",
        "STRUCTURED_DIR = TEMP_DIR / 'structured'\n",
        "UNSTRUCTURED_DIR = TEMP_DIR / 'unstructured'\n",
        "\n",
        "# Create directories\n",
        "STRUCTURED_DIR.mkdir(parents=True, exist_ok=True)\n",
        "UNSTRUCTURED_DIR.mkdir(parents=True, exist_ok=True)\n",
        "\n",
        "# Clean up old files\n",
        "print(\"ðŸ§¹ Cleaning up old data files...\")\n",
        "if TEMP_DIR.exists():\n",
        "    shutil.rmtree(TEMP_DIR)\n",
        "    TEMP_DIR.mkdir(parents=True, exist_ok=True)\n",
        "    STRUCTURED_DIR.mkdir(parents=True, exist_ok=True)\n",
        "    UNSTRUCTURED_DIR.mkdir(parents=True, exist_ok=True)\n",
        "\n",
        "print(f\"âœ… Temporary directories created at {TEMP_DIR}\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# PediatricDataGenerator class\n",
        "class PediatricDataGenerator:\n",
        "    \"\"\"Generate realistic pediatric healthcare data for demonstration purposes.\"\"\"\n",
        "    \n",
        "    def __init__(self, seed: int = 42):\n",
        "        \"\"\"Initialize generator with consistent seed for reproducible data.\"\"\"\n",
        "        random.seed(seed)\n",
        "        np.random.seed(seed)\n",
        "        self.fake = Faker()\n",
        "        Faker.seed(seed)\n",
        "        \n",
        "        # Houston-area zip codes for realistic geographic distribution\n",
        "        self.houston_zips = [\n",
        "            '77001', '77002', '77003', '77004', '77005', '77006', '77007', '77008',\n",
        "            '77009', '77010', '77011', '77012', '77013', '77014', '77015', '77016',\n",
        "            '77017', '77018', '77019', '77020', '77021', '77022', '77023', '77024',\n",
        "            '77025', '77026', '77027', '77028', '77029', '77030', '77031', '77032',\n",
        "            '77033', '77034', '77035', '77036', '77037', '77038', '77039', '77040',\n",
        "            '77041', '77042', '77043', '77044', '77045', '77046', '77047', '77048',\n",
        "            '77049', '77050', '77051', '77052', '77053', '77054', '77055', '77056',\n",
        "            '77057', '77058', '77059', '77060', '77061', '77062', '77063', '77064',\n",
        "            '77065', '77066', '77067', '77068', '77069', '77070', '77071', '77072',\n",
        "            '77073', '77074', '77075', '77076', '77077', '77078', '77079', '77080',\n",
        "            '77081', '77082', '77083', '77084', '77085', '77086', '77087', '77088',\n",
        "            '77089', '77090', '77091', '77092', '77093', '77094', '77095', '77096',\n",
        "            '77097', '77098', '77099', '77338', '77339', '77345', '77346', '77347',\n",
        "            '77354', '77357', '77365', '77373', '77375', '77377', '77379', '77380',\n",
        "            '77381', '77382', '77383', '77384', '77385', '77386', '77388', '77389',\n",
        "            '77391', '77393', '77396', '77401', '77402', '77406', '77407', '77429',\n",
        "            '77433', '77447', '77449', '77450', '77459', '77469', '77477', '77478',\n",
        "            '77479', '77484', '77489', '77493', '77494', '77498', '77502', '77503',\n",
        "            '77504', '77505', '77506', '77507', '77508', '77520', '77521', '77530',\n",
        "            '77532', '77536', '77539', '77546', '77547', '77562', '77571', '77573',\n",
        "            '77581', '77584', '77586', '77587', '77598'\n",
        "        ]\n",
        "        \n",
        "        # Common pediatric diagnoses with ICD-10 codes\n",
        "        self.pediatric_diagnoses = {\n",
        "            'J45.9': ('Asthma, unspecified', 0.08),  # 8% prevalence\n",
        "            'F90.9': ('ADHD, unspecified', 0.07),   # 7% prevalence\n",
        "            'E66.9': ('Obesity, unspecified', 0.18), # 18% prevalence\n",
        "            'F84.0': ('Autistic disorder', 0.025),   # 2.5% prevalence\n",
        "            'E10.9': ('Type 1 diabetes mellitus', 0.005), # 0.5% prevalence\n",
        "            'Q21.0': ('Ventricular septal defect', 0.008), # 0.8% prevalence\n",
        "            'H52.13': ('Myopia', 0.12),             # 12% prevalence\n",
        "            'L20.9': ('Atopic dermatitis', 0.15),   # 15% prevalence\n",
        "            'K59.00': ('Constipation', 0.10),       # 10% prevalence\n",
        "            'J06.9': ('Upper respiratory infection', 0.30), # 30% prevalence\n",
        "            'B34.9': ('Viral infection', 0.25),     # 25% prevalence\n",
        "            'K21.9': ('GERD', 0.08),                # 8% prevalence\n",
        "            'G40.909': ('Epilepsy', 0.007),         # 0.7% prevalence\n",
        "            'F32.9': ('Depression', 0.03),          # 3% prevalence (adolescents)\n",
        "            'F41.9': ('Anxiety disorder', 0.05),    # 5% prevalence\n",
        "            'M79.3': ('Growing pains', 0.15),       # 15% prevalence\n",
        "            'Z00.129': ('Well child exam', 0.95),   # 95% have routine checkups\n",
        "            'S72.001A': ('Fracture of femur', 0.02), # 2% prevalence\n",
        "            'T78.40XA': ('Allergy, unspecified', 0.20), # 20% prevalence\n",
        "            'H66.90': ('Otitis media', 0.35)        # 35% prevalence\n",
        "        }\n",
        "        \n",
        "        # Department mappings for Texas Children's Hospital\n",
        "        self.departments = [\n",
        "            'Emergency Department', 'Pediatric ICU', 'NICU', 'Cardiology',\n",
        "            'Neurology', 'Oncology', 'Orthopedics', 'Pulmonology',\n",
        "            'Gastroenterology', 'Endocrinology', 'Nephrology', 'Rheumatology',\n",
        "            'Dermatology', 'Ophthalmology', 'ENT', 'Psychiatry',\n",
        "            'General Pediatrics', 'Adolescent Medicine', 'Newborn Nursery',\n",
        "            'Ambulatory Surgery', 'Radiology', 'Laboratory', 'Pharmacy'\n",
        "        ]\n",
        "        \n",
        "        # Common pediatric medications\n",
        "        self.pediatric_medications = [\n",
        "            'Acetaminophen', 'Ibuprofen', 'Amoxicillin', 'Azithromycin',\n",
        "            'Albuterol', 'Fluticasone', 'Montelukast', 'Methylphenidate',\n",
        "            'Insulin', 'Prednisone', 'Cetirizine', 'Diphenhydramine',\n",
        "            'Omeprazole', 'Ranitidine', 'Simethicone', 'Polyethylene glycol',\n",
        "            'Hydrocortisone', 'Mupirocin', 'Miconazole', 'Nystatin'\n",
        "        ]\n",
        "        \n",
        "        # Lab test reference ranges by age\n",
        "        self.lab_reference_ranges = {\n",
        "            'Hemoglobin': {\n",
        "                '0-1': (14.0, 20.0), '1-3': (9.5, 13.0), '4-6': (10.5, 13.5),\n",
        "                '7-12': (11.0, 14.0), '13-15': (12.0, 15.2), '16-21': (12.6, 16.6)\n",
        "            },\n",
        "            'White Blood Cells': {\n",
        "                '0-1': (9000, 30000), '1-3': (6000, 17500), '4-6': (5500, 15500),\n",
        "                '7-12': (4500, 13500), '13-21': (4500, 11000)\n",
        "            },\n",
        "            'Platelet Count': {\n",
        "                '0-21': (150000, 450000)\n",
        "            },\n",
        "            'Glucose': {\n",
        "                '0-21': (70, 100)\n",
        "            },\n",
        "            'Creatinine': {\n",
        "                '0-1': (0.2, 0.4), '1-3': (0.3, 0.5), '4-6': (0.4, 0.6),\n",
        "                '7-12': (0.5, 0.8), '13-21': (0.6, 1.2)\n",
        "            }\n",
        "        }\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Add methods to PediatricDataGenerator class (continuing from previous cell)\n",
        "# This approach is necessary due to notebook cell size limitations\n",
        "\n",
        "# Helper methods\n",
        "def _generate_pediatric_age(self) -> int:\n",
        "    \"\"\"Generate age following pediatric population distribution.\"\"\"\n",
        "    weights = [25, 20, 15, 10, 10, 8, 6, 4, 2] + [1] * 13\n",
        "    return random.choices(range(22), weights=weights)[0]\n",
        "\n",
        "def _generate_race(self) -> str:\n",
        "    \"\"\"Generate race based on Texas demographics.\"\"\"\n",
        "    races = ['White', 'Black', 'Asian', 'Other', 'Native American', 'Pacific Islander']\n",
        "    weights = [0.40, 0.15, 0.05, 0.38, 0.01, 0.01]\n",
        "    return random.choices(races, weights=weights)[0]\n",
        "\n",
        "def _generate_ethnicity(self) -> str:\n",
        "    \"\"\"Generate ethnicity based on Texas demographics.\"\"\"\n",
        "    ethnicities = ['Hispanic', 'Non-Hispanic']\n",
        "    weights = [0.40, 0.60]\n",
        "    return random.choices(ethnicities, weights=weights)[0]\n",
        "\n",
        "def _generate_insurance_type(self, age: int) -> str:\n",
        "    \"\"\"Generate insurance type appropriate for pediatric population.\"\"\"\n",
        "    if age <= 18:\n",
        "        types = ['Medicaid', 'Commercial', 'CHIP', 'Self-pay']\n",
        "        weights = [0.45, 0.35, 0.15, 0.05]\n",
        "    else:\n",
        "        types = ['Medicaid', 'Commercial', 'Self-pay']\n",
        "        weights = [0.25, 0.65, 0.10]\n",
        "    return random.choices(types, weights=weights)[0]\n",
        "\n",
        "def _generate_language(self, ethnicity: str) -> str:\n",
        "    \"\"\"Generate primary language based on ethnicity.\"\"\"\n",
        "    if ethnicity == 'Hispanic':\n",
        "        languages = ['English', 'Spanish', 'English/Spanish']\n",
        "        weights = [0.40, 0.30, 0.30]\n",
        "    else:\n",
        "        languages = ['English', 'Spanish', 'Vietnamese', 'Chinese', 'Arabic', 'Other']\n",
        "        weights = [0.90, 0.03, 0.02, 0.02, 0.01, 0.02]\n",
        "    return random.choices(languages, weights=weights)[0]\n",
        "\n",
        "def _determine_encounter_count(self, age: int, base_count: int) -> int:\n",
        "    \"\"\"Determine number of encounters based on age.\"\"\"\n",
        "    if age == 0:\n",
        "        multiplier = 2.5\n",
        "    elif age <= 2:\n",
        "        multiplier = 1.8\n",
        "    elif age <= 5:\n",
        "        multiplier = 1.3\n",
        "    else:\n",
        "        multiplier = 1.0\n",
        "    \n",
        "    count = int(base_count * multiplier * random.uniform(0.5, 1.5))\n",
        "    return max(1, count)\n",
        "\n",
        "def _generate_encounter_date(self, patient_created_date) -> datetime:\n",
        "    \"\"\"Generate realistic encounter date.\"\"\"\n",
        "    days_since_creation = (datetime.now() - patient_created_date).days\n",
        "    if days_since_creation > 0:\n",
        "        days_ago = random.randint(0, min(days_since_creation, 365))\n",
        "        return datetime.now() - timedelta(days=days_ago)\n",
        "    return datetime.now()\n",
        "\n",
        "def _select_department(self, age: int) -> str:\n",
        "    \"\"\"Select appropriate department based on age.\"\"\"\n",
        "    if age == 0:\n",
        "        dept_weights = {\n",
        "            'NICU': 0.15, 'Newborn Nursery': 0.20, 'General Pediatrics': 0.40,\n",
        "            'Emergency Department': 0.15, 'Pediatric ICU': 0.05, 'Other': 0.05\n",
        "        }\n",
        "    elif age <= 5:\n",
        "        dept_weights = {\n",
        "            'General Pediatrics': 0.50, 'Emergency Department': 0.20,\n",
        "            'Pediatric ICU': 0.02, 'Pulmonology': 0.05, 'Gastroenterology': 0.05,\n",
        "            'ENT': 0.08, 'Other': 0.10\n",
        "        }\n",
        "    elif age <= 12:\n",
        "        dept_weights = {\n",
        "            'General Pediatrics': 0.45, 'Emergency Department': 0.15,\n",
        "            'Orthopedics': 0.10, 'Dermatology': 0.05, 'Ophthalmology': 0.05,\n",
        "            'Psychiatry': 0.05, 'Other': 0.15\n",
        "        }\n",
        "    else:\n",
        "        dept_weights = {\n",
        "            'General Pediatrics': 0.30, 'Adolescent Medicine': 0.20,\n",
        "            'Emergency Department': 0.15, 'Psychiatry': 0.10,\n",
        "            'Dermatology': 0.05, 'Orthopedics': 0.08, 'Other': 0.12\n",
        "        }\n",
        "    \n",
        "    departments = list(dept_weights.keys())\n",
        "    weights = list(dept_weights.values())\n",
        "    selected = random.choices(departments, weights=weights)[0]\n",
        "    \n",
        "    if selected == 'Other':\n",
        "        return random.choice(self.departments)\n",
        "    return selected\n",
        "\n",
        "def _determine_encounter_type(self, department: str) -> str:\n",
        "    \"\"\"Determine encounter type based on department.\"\"\"\n",
        "    if department == 'Emergency Department':\n",
        "        return 'Emergency'\n",
        "    elif department in ['Pediatric ICU', 'NICU']:\n",
        "        return 'Inpatient'\n",
        "    elif department in ['Ambulatory Surgery']:\n",
        "        return 'Surgical'\n",
        "    else:\n",
        "        types = ['Outpatient', 'Outpatient', 'Outpatient', 'Inpatient']\n",
        "        weights = [0.85, 0.10, 0.03, 0.02]\n",
        "        return random.choices(types, weights=weights)[0]\n",
        "\n",
        "def _generate_physician_name(self) -> str:\n",
        "    \"\"\"Generate realistic physician name.\"\"\"\n",
        "    return f\"Dr. {self.fake.last_name()}\"\n",
        "\n",
        "def _generate_discharge_date(self, admission_date: datetime, encounter_type: str) -> Optional[datetime]:\n",
        "    \"\"\"Generate discharge date based on encounter type.\"\"\"\n",
        "    if encounter_type == 'Outpatient':\n",
        "        return admission_date\n",
        "    elif encounter_type == 'Emergency':\n",
        "        hours = random.choices([4, 8, 12, 24], weights=[0.6, 0.2, 0.15, 0.05])[0]\n",
        "        return admission_date + timedelta(hours=hours)\n",
        "    elif encounter_type == 'Inpatient':\n",
        "        days = random.choices([1, 2, 3, 5, 7, 10], weights=[0.3, 0.3, 0.2, 0.1, 0.07, 0.03])[0]\n",
        "        return admission_date + timedelta(days=days)\n",
        "    elif encounter_type == 'Surgical':\n",
        "        days = random.choices([0, 1, 2], weights=[0.6, 0.3, 0.1])[0]\n",
        "        return admission_date + timedelta(days=days)\n",
        "    return None\n",
        "\n",
        "def _generate_chief_complaint(self, age: int) -> str:\n",
        "    \"\"\"Generate age-appropriate chief complaint.\"\"\"\n",
        "    if age == 0:\n",
        "        complaints = ['Fever', 'Poor feeding', 'Respiratory distress', 'Jaundice', \n",
        "                     'Vomiting', 'Routine newborn care']\n",
        "    elif age <= 2:\n",
        "        complaints = ['Fever', 'Cough', 'Vomiting', 'Diarrhea', 'Ear pain', \n",
        "                     'Rash', 'Well child check']\n",
        "    elif age <= 5:\n",
        "        complaints = ['Fever', 'Cough', 'Abdominal pain', 'Ear pain', 'Sore throat',\n",
        "                     'Injury', 'Well child check', 'Asthma']\n",
        "    elif age <= 12:\n",
        "        complaints = ['Abdominal pain', 'Headache', 'Injury', 'Asthma', 'Sore throat',\n",
        "                     'Fever', 'Well child check', 'ADHD follow-up']\n",
        "    else:\n",
        "        complaints = ['Abdominal pain', 'Headache', 'Injury', 'Depression screening',\n",
        "                     'Anxiety', 'Acne', 'Sports physical', 'Well adolescent check']\n",
        "    \n",
        "    return random.choice(complaints)\n",
        "\n",
        "# Add these methods to the PediatricDataGenerator class\n",
        "PediatricDataGenerator._generate_pediatric_age = _generate_pediatric_age\n",
        "PediatricDataGenerator._generate_race = _generate_race\n",
        "PediatricDataGenerator._generate_ethnicity = _generate_ethnicity\n",
        "PediatricDataGenerator._generate_insurance_type = _generate_insurance_type\n",
        "PediatricDataGenerator._generate_language = _generate_language\n",
        "PediatricDataGenerator._determine_encounter_count = _determine_encounter_count\n",
        "PediatricDataGenerator._generate_encounter_date = _generate_encounter_date\n",
        "PediatricDataGenerator._select_department = _select_department\n",
        "PediatricDataGenerator._determine_encounter_type = _determine_encounter_type\n",
        "PediatricDataGenerator._generate_physician_name = _generate_physician_name\n",
        "PediatricDataGenerator._generate_discharge_date = _generate_discharge_date\n",
        "PediatricDataGenerator._generate_chief_complaint = _generate_chief_complaint\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Main data generation methods for PediatricDataGenerator\n",
        "\n",
        "def generate_patient_demographics(self, count: int) -> List[Dict]:\n",
        "    \"\"\"Generate realistic pediatric patient demographics.\"\"\"\n",
        "    patients = []\n",
        "    \n",
        "    for i in range(count):\n",
        "        # Generate age with higher concentration in younger years\n",
        "        age = self._generate_pediatric_age()\n",
        "        birth_date = datetime.now() - timedelta(days=age * 365.25)\n",
        "        \n",
        "        # Generate basic demographics\n",
        "        gender = random.choice(['M', 'F'])\n",
        "        race = self._generate_race()\n",
        "        ethnicity = self._generate_ethnicity()\n",
        "        \n",
        "        patient = {\n",
        "            'patient_id': f\"TCH-{i+1:06d}\",\n",
        "            'mrn': f\"MRN{random.randint(10000000, 99999999)}\",\n",
        "            'first_name': self.fake.first_name_male() if gender == 'M' else self.fake.first_name_female(),\n",
        "            'last_name': self.fake.last_name(),\n",
        "            'date_of_birth': birth_date.date(),\n",
        "            'age': age,\n",
        "            'gender': gender,\n",
        "            'race': race,\n",
        "            'ethnicity': ethnicity,\n",
        "            'zip_code': random.choice(self.houston_zips),\n",
        "            'insurance_type': self._generate_insurance_type(age),\n",
        "            'language': self._generate_language(ethnicity),\n",
        "            'created_date': self.fake.date_time_between(start_date='-5y', end_date='now'),\n",
        "            'updated_date': datetime.now()\n",
        "        }\n",
        "        patients.append(patient)\n",
        "    \n",
        "    return patients\n",
        "\n",
        "def generate_encounters(self, patients: List[Dict], encounters_per_patient: int = 5) -> List[Dict]:\n",
        "    \"\"\"Generate realistic encounter data for patients.\"\"\"\n",
        "    encounters = []\n",
        "    encounter_id = 1\n",
        "    \n",
        "    for patient in patients:\n",
        "        patient_age = patient['age']\n",
        "        \n",
        "        # Determine number of encounters based on age and conditions\n",
        "        num_encounters = self._determine_encounter_count(patient_age, encounters_per_patient)\n",
        "        \n",
        "        for _ in range(num_encounters):\n",
        "            encounter_date = self._generate_encounter_date(patient['created_date'])\n",
        "            department = self._select_department(patient_age)\n",
        "            encounter_type = self._determine_encounter_type(department)\n",
        "            \n",
        "            encounter = {\n",
        "                'encounter_id': f\"ENC-{encounter_id:08d}\",\n",
        "                'patient_id': patient['patient_id'],\n",
        "                'encounter_date': encounter_date,\n",
        "                'encounter_type': encounter_type,\n",
        "                'department': department,\n",
        "                'attending_physician': self._generate_physician_name(),\n",
        "                'admission_date': encounter_date,\n",
        "                'discharge_date': self._generate_discharge_date(encounter_date, encounter_type),\n",
        "                'length_of_stay': None,  # Will calculate based on dates\n",
        "                'chief_complaint': self._generate_chief_complaint(patient_age),\n",
        "                'status': random.choice(['Completed', 'In Progress', 'Scheduled']),\n",
        "                'created_date': encounter_date,\n",
        "                'updated_date': datetime.now()\n",
        "            }\n",
        "            \n",
        "            # Calculate length of stay\n",
        "            if encounter['discharge_date']:\n",
        "                encounter['length_of_stay'] = (encounter['discharge_date'] - encounter_date).days\n",
        "            \n",
        "            encounters.append(encounter)\n",
        "            encounter_id += 1\n",
        "    \n",
        "    return encounters\n",
        "\n",
        "def generate_diagnoses(self, encounters: List[Dict]) -> List[Dict]:\n",
        "    \"\"\"Generate diagnosis data linked to encounters.\"\"\"\n",
        "    diagnoses = []\n",
        "    diagnosis_id = 1\n",
        "    \n",
        "    for encounter in encounters:\n",
        "        # Determine number of diagnoses for this encounter\n",
        "        num_diagnoses = random.choices([1, 2, 3], weights=[0.6, 0.3, 0.1])[0]\n",
        "        \n",
        "        # Select diagnoses based on prevalence\n",
        "        selected_codes = []\n",
        "        for _ in range(num_diagnoses):\n",
        "            code, (desc, prevalence) = random.choice(list(self.pediatric_diagnoses.items()))\n",
        "            if random.random() < prevalence * 2:  # Increase chance for realistic distribution\n",
        "                selected_codes.append((code, desc))\n",
        "        \n",
        "        # Ensure at least one diagnosis\n",
        "        if not selected_codes:\n",
        "            code, (desc, _) = random.choice(list(self.pediatric_diagnoses.items()))\n",
        "            selected_codes.append((code, desc))\n",
        "        \n",
        "        # Create diagnosis records\n",
        "        for i, (code, desc) in enumerate(selected_codes):\n",
        "            diagnosis = {\n",
        "                'diagnosis_id': f\"DX-{diagnosis_id:08d}\",\n",
        "                'encounter_id': encounter['encounter_id'],\n",
        "                'patient_id': encounter['patient_id'],\n",
        "                'icd10_code': code,\n",
        "                'description': desc,\n",
        "                'diagnosis_type': 'Primary' if i == 0 else 'Secondary',\n",
        "                'diagnosis_date': encounter['encounter_date'],\n",
        "                'created_date': encounter['encounter_date'],\n",
        "                'updated_date': datetime.now()\n",
        "            }\n",
        "            diagnoses.append(diagnosis)\n",
        "            diagnosis_id += 1\n",
        "    \n",
        "    return diagnoses\n",
        "\n",
        "def generate_lab_results(self, encounters: List[Dict], patients: List[Dict]) -> List[Dict]:\n",
        "    \"\"\"Generate lab results linked to encounters.\"\"\"\n",
        "    lab_results = []\n",
        "    lab_id = 1\n",
        "    \n",
        "    # Create patient lookup\n",
        "    patient_lookup = {p['patient_id']: p for p in patients}\n",
        "    \n",
        "    # Common lab tests\n",
        "    lab_tests = [\n",
        "        ('CBC', 'Complete Blood Count', 0.40),\n",
        "        ('BMP', 'Basic Metabolic Panel', 0.30),\n",
        "        ('UA', 'Urinalysis', 0.25),\n",
        "        ('Strep', 'Strep Test', 0.15),\n",
        "        ('Flu', 'Influenza Test', 0.10),\n",
        "        ('COVID', 'COVID-19 Test', 0.08),\n",
        "        ('RSV', 'RSV Test', 0.12),\n",
        "        ('Blood Culture', 'Blood Culture', 0.05)\n",
        "    ]\n",
        "    \n",
        "    for encounter in encounters:\n",
        "        patient = patient_lookup[encounter['patient_id']]\n",
        "        patient_age = patient['age']\n",
        "        \n",
        "        # Determine if labs are needed\n",
        "        lab_probability = 0.2  # Base probability\n",
        "        if encounter['encounter_type'] in ['Emergency', 'Inpatient']:\n",
        "            lab_probability = 0.8\n",
        "        elif encounter['department'] in ['Pediatric ICU', 'NICU']:\n",
        "            lab_probability = 0.95\n",
        "        \n",
        "        if random.random() < lab_probability:\n",
        "            # Select which labs to order\n",
        "            num_labs = random.choices([1, 2, 3, 4], weights=[0.4, 0.3, 0.2, 0.1])[0]\n",
        "            selected_labs = random.sample(lab_tests, min(num_labs, len(lab_tests)))\n",
        "            \n",
        "            for test_code, test_name, _ in selected_labs:\n",
        "                # Generate appropriate results based on test type\n",
        "                if test_code == 'CBC':\n",
        "                    results = self._generate_cbc_results(patient_age)\n",
        "                elif test_code == 'BMP':\n",
        "                    results = self._generate_bmp_results(patient_age)\n",
        "                else:\n",
        "                    results = self._generate_generic_results(test_code)\n",
        "                \n",
        "                lab_result = {\n",
        "                    'lab_result_id': f\"LAB-{lab_id:08d}\",\n",
        "                    'encounter_id': encounter['encounter_id'],\n",
        "                    'patient_id': encounter['patient_id'],\n",
        "                    'test_code': test_code,\n",
        "                    'test_name': test_name,\n",
        "                    'result_value': results['value'],\n",
        "                    'result_unit': results['unit'],\n",
        "                    'reference_range': results['reference'],\n",
        "                    'abnormal_flag': results['abnormal'],\n",
        "                    'collection_date': encounter['encounter_date'] + timedelta(hours=random.randint(0, 4)),\n",
        "                    'result_date': encounter['encounter_date'] + timedelta(hours=random.randint(4, 8)),\n",
        "                    'status': 'Final',\n",
        "                    'created_date': encounter['encounter_date'],\n",
        "                    'updated_date': datetime.now()\n",
        "                }\n",
        "                lab_results.append(lab_result)\n",
        "                lab_id += 1\n",
        "    \n",
        "    return lab_results\n",
        "\n",
        "# Add these methods to PediatricDataGenerator\n",
        "PediatricDataGenerator.generate_patient_demographics = generate_patient_demographics\n",
        "PediatricDataGenerator.generate_encounters = generate_encounters\n",
        "PediatricDataGenerator.generate_diagnoses = generate_diagnoses\n",
        "PediatricDataGenerator.generate_lab_results = generate_lab_results\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Additional methods for PediatricDataGenerator - Lab result generators and more\n",
        "\n",
        "def _generate_cbc_results(self, age: int) -> Dict:\n",
        "    \"\"\"Generate age-appropriate CBC results.\"\"\"\n",
        "    # Get age range key\n",
        "    if age == 0:\n",
        "        age_key = '0-1'\n",
        "    elif age <= 3:\n",
        "        age_key = '1-3'\n",
        "    elif age <= 6:\n",
        "        age_key = '4-6'\n",
        "    elif age <= 12:\n",
        "        age_key = '7-12'\n",
        "    elif age <= 15:\n",
        "        age_key = '13-15'\n",
        "    else:\n",
        "        age_key = '16-21'\n",
        "    \n",
        "    # Generate hemoglobin\n",
        "    hgb_range = self.lab_reference_ranges['Hemoglobin'][age_key]\n",
        "    hgb_value = round(random.uniform(hgb_range[0] - 1, hgb_range[1] + 1), 1)\n",
        "    \n",
        "    return {\n",
        "        'value': str(hgb_value),\n",
        "        'unit': 'g/dL',\n",
        "        'reference': f\"{hgb_range[0]}-{hgb_range[1]}\",\n",
        "        'abnormal': 'L' if hgb_value < hgb_range[0] else ('H' if hgb_value > hgb_range[1] else 'N')\n",
        "    }\n",
        "\n",
        "def _generate_bmp_results(self, age: int) -> Dict:\n",
        "    \"\"\"Generate basic metabolic panel results.\"\"\"\n",
        "    glucose_range = self.lab_reference_ranges['Glucose']['0-21']\n",
        "    glucose_value = random.randint(glucose_range[0] - 10, glucose_range[1] + 20)\n",
        "    \n",
        "    return {\n",
        "        'value': str(glucose_value),\n",
        "        'unit': 'mg/dL',\n",
        "        'reference': f\"{glucose_range[0]}-{glucose_range[1]}\",\n",
        "        'abnormal': 'L' if glucose_value < glucose_range[0] else ('H' if glucose_value > glucose_range[1] else 'N')\n",
        "    }\n",
        "\n",
        "def _generate_generic_results(self, test_code: str) -> Dict:\n",
        "    \"\"\"Generate generic test results.\"\"\"\n",
        "    if test_code in ['Strep', 'Flu', 'COVID', 'RSV']:\n",
        "        result = random.choices(['Positive', 'Negative'], weights=[0.2, 0.8])[0]\n",
        "        return {\n",
        "            'value': result,\n",
        "            'unit': '',\n",
        "            'reference': 'Negative',\n",
        "            'abnormal': 'A' if result == 'Positive' else 'N'\n",
        "        }\n",
        "    else:\n",
        "        return {\n",
        "            'value': 'See report',\n",
        "            'unit': '',\n",
        "            'reference': '',\n",
        "            'abnormal': 'N'\n",
        "        }\n",
        "\n",
        "def generate_medications(self, encounters: List[Dict], diagnoses: List[Dict]) -> List[Dict]:\n",
        "    \"\"\"Generate medication data linked to encounters and diagnoses.\"\"\"\n",
        "    medications = []\n",
        "    med_id = 1\n",
        "    \n",
        "    # Create diagnosis lookup by encounter\n",
        "    encounter_diagnoses = {}\n",
        "    for dx in diagnoses:\n",
        "        if dx['encounter_id'] not in encounter_diagnoses:\n",
        "            encounter_diagnoses[dx['encounter_id']] = []\n",
        "        encounter_diagnoses[dx['encounter_id']].append(dx)\n",
        "    \n",
        "    # Medication mapping by diagnosis\n",
        "    diagnosis_medications = {\n",
        "        'J45.9': ['Albuterol', 'Fluticasone', 'Montelukast'],  # Asthma\n",
        "        'F90.9': ['Methylphenidate'],  # ADHD\n",
        "        'E10.9': ['Insulin'],  # Diabetes\n",
        "        'J06.9': ['Acetaminophen', 'Ibuprofen'],  # URI\n",
        "        'H66.90': ['Amoxicillin'],  # Otitis media\n",
        "        'L20.9': ['Hydrocortisone'],  # Dermatitis\n",
        "        'K21.9': ['Omeprazole'],  # GERD\n",
        "        'K59.00': ['Polyethylene glycol']  # Constipation\n",
        "    }\n",
        "    \n",
        "    for encounter in encounters:\n",
        "        # Determine if medications are prescribed\n",
        "        med_probability = 0.3  # Base probability\n",
        "        if encounter['encounter_type'] in ['Emergency', 'Inpatient']:\n",
        "            med_probability = 0.8\n",
        "        \n",
        "        if random.random() < med_probability:\n",
        "            # Get diagnoses for this encounter\n",
        "            enc_diagnoses = encounter_diagnoses.get(encounter['encounter_id'], [])\n",
        "            \n",
        "            prescribed_meds = set()\n",
        "            \n",
        "            # Add medications based on diagnoses\n",
        "            for dx in enc_diagnoses:\n",
        "                if dx['icd10_code'] in diagnosis_medications:\n",
        "                    for med in diagnosis_medications[dx['icd10_code']]:\n",
        "                        prescribed_meds.add(med)\n",
        "            \n",
        "            # Add some general medications\n",
        "            if encounter['encounter_type'] == 'Emergency':\n",
        "                prescribed_meds.add(random.choice(['Acetaminophen', 'Ibuprofen']))\n",
        "            \n",
        "            # Create medication records\n",
        "            for med_name in prescribed_meds:\n",
        "                medication = {\n",
        "                    'medication_id': f\"MED-{med_id:08d}\",\n",
        "                    'encounter_id': encounter['encounter_id'],\n",
        "                    'patient_id': encounter['patient_id'],\n",
        "                    'medication_name': med_name,\n",
        "                    'dosage': self._generate_dosage(med_name),\n",
        "                    'frequency': self._generate_frequency(med_name),\n",
        "                    'route': self._generate_route(med_name),\n",
        "                    'start_date': encounter['encounter_date'],\n",
        "                    'end_date': encounter['encounter_date'] + timedelta(days=random.choice([5, 7, 10, 14])),\n",
        "                    'status': random.choice(['Active', 'Completed', 'Discontinued']),\n",
        "                    'prescribing_physician': encounter['attending_physician'],\n",
        "                    'created_date': encounter['encounter_date'],\n",
        "                    'updated_date': datetime.now()\n",
        "                }\n",
        "                medications.append(medication)\n",
        "                med_id += 1\n",
        "    \n",
        "    return medications\n",
        "\n",
        "def _generate_dosage(self, medication_name: str) -> str:\n",
        "    \"\"\"Generate appropriate dosage for medication.\"\"\"\n",
        "    dosages = {\n",
        "        'Acetaminophen': '15 mg/kg',\n",
        "        'Ibuprofen': '10 mg/kg',\n",
        "        'Amoxicillin': '45 mg/kg/day',\n",
        "        'Albuterol': '2 puffs',\n",
        "        'Fluticasone': '1 puff',\n",
        "        'Methylphenidate': '5 mg',\n",
        "        'Insulin': '0.5 units/kg/day'\n",
        "    }\n",
        "    return dosages.get(medication_name, '1 dose')\n",
        "\n",
        "def _generate_frequency(self, medication_name: str) -> str:\n",
        "    \"\"\"Generate appropriate frequency for medication.\"\"\"\n",
        "    frequencies = {\n",
        "        'Acetaminophen': 'every 4-6 hours as needed',\n",
        "        'Ibuprofen': 'every 6-8 hours as needed',\n",
        "        'Amoxicillin': 'twice daily',\n",
        "        'Albuterol': 'every 4 hours as needed',\n",
        "        'Fluticasone': 'twice daily',\n",
        "        'Methylphenidate': 'once daily',\n",
        "        'Insulin': 'as directed'\n",
        "    }\n",
        "    return frequencies.get(medication_name, 'as directed')\n",
        "\n",
        "def _generate_route(self, medication_name: str) -> str:\n",
        "    \"\"\"Generate appropriate route for medication.\"\"\"\n",
        "    if medication_name in ['Albuterol', 'Fluticasone']:\n",
        "        return 'Inhalation'\n",
        "    elif medication_name == 'Insulin':\n",
        "        return 'Subcutaneous'\n",
        "    elif medication_name == 'Hydrocortisone':\n",
        "        return 'Topical'\n",
        "    else:\n",
        "        return 'Oral'\n",
        "\n",
        "def generate_vital_signs(self, encounters: List[Dict], patients: List[Dict]) -> List[Dict]:\n",
        "    \"\"\"Generate vital signs data for encounters.\"\"\"\n",
        "    vital_signs = []\n",
        "    vital_id = 1\n",
        "    \n",
        "    # Create patient lookup\n",
        "    patient_lookup = {p['patient_id']: p for p in patients}\n",
        "    \n",
        "    for encounter in encounters:\n",
        "        patient = patient_lookup[encounter['patient_id']]\n",
        "        patient_age = patient['age']\n",
        "        \n",
        "        # Generate vitals for most encounters\n",
        "        if random.random() < 0.9:\n",
        "            # Number of vital sign sets\n",
        "            num_sets = 1\n",
        "            if encounter['encounter_type'] == 'Inpatient':\n",
        "                num_sets = random.randint(3, 8)\n",
        "            elif encounter['encounter_type'] == 'Emergency':\n",
        "                num_sets = random.randint(2, 4)\n",
        "            \n",
        "            for i in range(num_sets):\n",
        "                vital_time = encounter['encounter_date'] + timedelta(hours=i * 4)\n",
        "                \n",
        "                vital = {\n",
        "                    'vital_sign_id': f\"VS-{vital_id:08d}\",\n",
        "                    'encounter_id': encounter['encounter_id'],\n",
        "                    'patient_id': encounter['patient_id'],\n",
        "                    'measurement_date': vital_time,\n",
        "                    'temperature': self._generate_temperature(),\n",
        "                    'heart_rate': self._generate_heart_rate(patient_age),\n",
        "                    'respiratory_rate': self._generate_respiratory_rate(patient_age),\n",
        "                    'blood_pressure_systolic': self._generate_bp_systolic(patient_age),\n",
        "                    'blood_pressure_diastolic': self._generate_bp_diastolic(patient_age),\n",
        "                    'oxygen_saturation': self._generate_oxygen_saturation(),\n",
        "                    'weight_kg': self._generate_weight(patient_age),\n",
        "                    'height_cm': self._generate_height(patient_age),\n",
        "                    'created_date': vital_time,\n",
        "                    'updated_date': datetime.now()\n",
        "                }\n",
        "                vital_signs.append(vital)\n",
        "                vital_id += 1\n",
        "    \n",
        "    return vital_signs\n",
        "\n",
        "# Vital sign generation helpers\n",
        "def _generate_temperature(self) -> float:\n",
        "    \"\"\"Generate body temperature in Celsius.\"\"\"\n",
        "    return round(random.uniform(36.0, 38.5), 1)\n",
        "\n",
        "def _generate_heart_rate(self, age: int) -> int:\n",
        "    \"\"\"Generate age-appropriate heart rate.\"\"\"\n",
        "    if age == 0:\n",
        "        return random.randint(100, 160)\n",
        "    elif age <= 1:\n",
        "        return random.randint(90, 150)\n",
        "    elif age <= 3:\n",
        "        return random.randint(80, 130)\n",
        "    elif age <= 6:\n",
        "        return random.randint(75, 115)\n",
        "    elif age <= 12:\n",
        "        return random.randint(70, 110)\n",
        "    else:\n",
        "        return random.randint(60, 100)\n",
        "\n",
        "def _generate_respiratory_rate(self, age: int) -> int:\n",
        "    \"\"\"Generate age-appropriate respiratory rate.\"\"\"\n",
        "    if age == 0:\n",
        "        return random.randint(30, 60)\n",
        "    elif age <= 1:\n",
        "        return random.randint(24, 40)\n",
        "    elif age <= 3:\n",
        "        return random.randint(22, 34)\n",
        "    elif age <= 6:\n",
        "        return random.randint(20, 30)\n",
        "    elif age <= 12:\n",
        "        return random.randint(18, 26)\n",
        "    else:\n",
        "        return random.randint(12, 20)\n",
        "\n",
        "def _generate_bp_systolic(self, age: int) -> int:\n",
        "    \"\"\"Generate age-appropriate systolic blood pressure.\"\"\"\n",
        "    if age <= 1:\n",
        "        return random.randint(70, 95)\n",
        "    elif age <= 3:\n",
        "        return random.randint(80, 100)\n",
        "    elif age <= 6:\n",
        "        return random.randint(85, 105)\n",
        "    elif age <= 12:\n",
        "        return random.randint(90, 110)\n",
        "    else:\n",
        "        return random.randint(100, 120)\n",
        "\n",
        "def _generate_bp_diastolic(self, age: int) -> int:\n",
        "    \"\"\"Generate age-appropriate diastolic blood pressure.\"\"\"\n",
        "    if age <= 1:\n",
        "        return random.randint(45, 65)\n",
        "    elif age <= 3:\n",
        "        return random.randint(50, 65)\n",
        "    elif age <= 6:\n",
        "        return random.randint(55, 70)\n",
        "    elif age <= 12:\n",
        "        return random.randint(60, 75)\n",
        "    else:\n",
        "        return random.randint(65, 80)\n",
        "\n",
        "def _generate_oxygen_saturation(self) -> int:\n",
        "    \"\"\"Generate oxygen saturation percentage.\"\"\"\n",
        "    return random.choices(\n",
        "        [98, 99, 100, 97, 96, 95],\n",
        "        weights=[0.3, 0.3, 0.2, 0.1, 0.05, 0.05]\n",
        "    )[0]\n",
        "\n",
        "def _generate_weight(self, age: int) -> float:\n",
        "    \"\"\"Generate age-appropriate weight in kg.\"\"\"\n",
        "    if age == 0:\n",
        "        return round(random.uniform(2.5, 4.5), 1)\n",
        "    elif age == 1:\n",
        "        return round(random.uniform(8, 12), 1)\n",
        "    elif age <= 3:\n",
        "        return round(random.uniform(12, 18), 1)\n",
        "    elif age <= 6:\n",
        "        return round(random.uniform(16, 25), 1)\n",
        "    elif age <= 12:\n",
        "        return round(random.uniform(25, 50), 1)\n",
        "    else:\n",
        "        return round(random.uniform(45, 80), 1)\n",
        "\n",
        "def _generate_height(self, age: int) -> float:\n",
        "    \"\"\"Generate age-appropriate height in cm.\"\"\"\n",
        "    if age == 0:\n",
        "        return round(random.uniform(45, 55), 1)\n",
        "    elif age == 1:\n",
        "        return round(random.uniform(70, 80), 1)\n",
        "    elif age <= 3:\n",
        "        return round(random.uniform(85, 100), 1)\n",
        "    elif age <= 6:\n",
        "        return round(random.uniform(100, 120), 1)\n",
        "    elif age <= 12:\n",
        "        return round(random.uniform(120, 150), 1)\n",
        "    else:\n",
        "        return round(random.uniform(150, 180), 1)\n",
        "\n",
        "# Add all methods to PediatricDataGenerator\n",
        "PediatricDataGenerator._generate_cbc_results = _generate_cbc_results\n",
        "PediatricDataGenerator._generate_bmp_results = _generate_bmp_results\n",
        "PediatricDataGenerator._generate_generic_results = _generate_generic_results\n",
        "PediatricDataGenerator.generate_medications = generate_medications\n",
        "PediatricDataGenerator._generate_dosage = _generate_dosage\n",
        "PediatricDataGenerator._generate_frequency = _generate_frequency\n",
        "PediatricDataGenerator._generate_route = _generate_route\n",
        "PediatricDataGenerator.generate_vital_signs = generate_vital_signs\n",
        "PediatricDataGenerator._generate_temperature = _generate_temperature\n",
        "PediatricDataGenerator._generate_heart_rate = _generate_heart_rate\n",
        "PediatricDataGenerator._generate_respiratory_rate = _generate_respiratory_rate\n",
        "PediatricDataGenerator._generate_bp_systolic = _generate_bp_systolic\n",
        "PediatricDataGenerator._generate_bp_diastolic = _generate_bp_diastolic\n",
        "PediatricDataGenerator._generate_oxygen_saturation = _generate_oxygen_saturation\n",
        "PediatricDataGenerator._generate_weight = _generate_weight\n",
        "PediatricDataGenerator._generate_height = _generate_height\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# ClinicalNotesGenerator class\n",
        "class ClinicalNotesGenerator:\n",
        "    \"\"\"Generate realistic clinical documentation for pediatric patients.\"\"\"\n",
        "    \n",
        "    def __init__(self, seed: int = 42):\n",
        "        \"\"\"Initialize generator with consistent seed for reproducible data.\"\"\"\n",
        "        random.seed(seed)\n",
        "        self.fake = Faker()\n",
        "        Faker.seed(seed)\n",
        "        \n",
        "        # Clinical note templates and components\n",
        "        self.note_types = [\n",
        "            'Progress Note', 'Admission Note', 'Discharge Summary', \n",
        "            'Consultation Note', 'Nursing Note', 'Emergency Department Note',\n",
        "            'Procedure Note', 'Follow-up Note'\n",
        "        ]\n",
        "        \n",
        "        self.pediatric_symptoms = [\n",
        "            'fever', 'cough', 'vomiting', 'diarrhea', 'abdominal pain', 'headache',\n",
        "            'sore throat', 'ear pain', 'rash', 'congestion', 'wheezing', 'fatigue',\n",
        "            'poor feeding', 'irritability', 'difficulty breathing', 'chest pain',\n",
        "            'joint pain', 'muscle aches', 'nausea', 'dizziness'\n",
        "        ]\n",
        "        \n",
        "        self.physical_exam_findings = {\n",
        "            'general': ['alert', 'responsive', 'well-appearing', 'ill-appearing', 'anxious', 'comfortable'],\n",
        "            'vital_signs': ['stable', 'normal for age', 'elevated temperature', 'tachycardic', 'tachypneic'],\n",
        "            'heent': ['normocephalic', 'atraumatic', 'pupils equal and reactive', 'TMs clear', 'throat erythematous'],\n",
        "            'cardiovascular': ['regular rate and rhythm', 'no murmurs', 'good perfusion', 'normal S1 S2'],\n",
        "            'respiratory': ['clear to auscultation', 'good air movement', 'no wheezes', 'no rales', 'symmetric expansion'],\n",
        "            'abdomen': ['soft', 'non-tender', 'non-distended', 'normal bowel sounds', 'no organomegaly'],\n",
        "            'extremities': ['no edema', 'full range of motion', 'no deformity', 'good strength'],\n",
        "            'neurologic': ['alert and oriented', 'no focal deficits', 'cranial nerves intact', 'reflexes normal'],\n",
        "            'skin': ['warm and dry', 'no rash', 'good turgor', 'no lesions']\n",
        "        }\n",
        "        \n",
        "        self.assessment_plans = {\n",
        "            'J45.9': {  # Asthma\n",
        "                'assessment': 'Asthma exacerbation',\n",
        "                'plan': [\n",
        "                    'Continue albuterol inhaler 2 puffs every 4-6 hours as needed',\n",
        "                    'Start/continue inhaled corticosteroid therapy',\n",
        "                    'Follow up with pulmonology in 2-4 weeks',\n",
        "                    'Return to ED if worsening symptoms',\n",
        "                    'Asthma action plan reviewed with family'\n",
        "                ]\n",
        "            },\n",
        "            'F90.9': {  # ADHD\n",
        "                'assessment': 'Attention deficit hyperactivity disorder',\n",
        "                'plan': [\n",
        "                    'Continue current medication regimen',\n",
        "                    'Behavioral therapy referral',\n",
        "                    'School accommodations discussed',\n",
        "                    'Follow up in 3 months',\n",
        "                    'Monitor growth and development'\n",
        "                ]\n",
        "            },\n",
        "            'E10.9': {  # Type 1 Diabetes\n",
        "                'assessment': 'Type 1 diabetes mellitus',\n",
        "                'plan': [\n",
        "                    'Continue insulin per sliding scale',\n",
        "                    'Blood glucose monitoring 4x daily',\n",
        "                    'Endocrinology follow-up in 3 months',\n",
        "                    'Nutrition counseling',\n",
        "                    'Annual ophthalmology exam'\n",
        "                ]\n",
        "            },\n",
        "            'J06.9': {  # Upper respiratory infection\n",
        "                'assessment': 'Viral upper respiratory infection',\n",
        "                'plan': [\n",
        "                    'Supportive care with rest and fluids',\n",
        "                    'Acetaminophen or ibuprofen for fever',\n",
        "                    'Saline nasal drops for congestion',\n",
        "                    'Return if symptoms worsen or persist >10 days',\n",
        "                    'No antibiotics indicated'\n",
        "                ]\n",
        "            }\n",
        "        }\n",
        "        \n",
        "        self.radiology_findings = {\n",
        "            'chest_xray': [\n",
        "                'lungs are clear bilaterally',\n",
        "                'no acute cardiopulmonary process',\n",
        "                'heart size normal for age',\n",
        "                'no pneumonia or pneumothorax',\n",
        "                'costophrenic angles are sharp'\n",
        "            ],\n",
        "            'abdominal_xray': [\n",
        "                'normal bowel gas pattern',\n",
        "                'no evidence of obstruction',\n",
        "                'no free air',\n",
        "                'normal soft tissue shadows',\n",
        "                'no abnormal calcifications'\n",
        "            ],\n",
        "            'brain_mri': [\n",
        "                'normal brain parenchyma',\n",
        "                'no evidence of mass effect',\n",
        "                'ventricles normal in size',\n",
        "                'no abnormal enhancement',\n",
        "                'normal gray-white differentiation'\n",
        "            ],\n",
        "            'brain_ct': [\n",
        "                'no acute intracranial abnormality',\n",
        "                'ventricles and sulci normal for age',\n",
        "                'no midline shift',\n",
        "                'no hemorrhage or mass effect',\n",
        "                'normal gray-white differentiation'\n",
        "            ],\n",
        "            'ultrasound_abdomen': [\n",
        "                'liver normal in size and echotexture',\n",
        "                'gallbladder normal without stones',\n",
        "                'kidneys normal in size and position',\n",
        "                'no free fluid',\n",
        "                'normal bowel peristalsis'\n",
        "            ],\n",
        "            'echo': [\n",
        "                'normal cardiac structure and function',\n",
        "                'ejection fraction normal',\n",
        "                'no valvular abnormalities',\n",
        "                'no pericardial effusion',\n",
        "                'normal chamber sizes'\n",
        "            ]\n",
        "        }\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Methods for ClinicalNotesGenerator\n",
        "\n",
        "def generate_progress_note(self, patient: Dict, encounter: Dict, diagnoses: List[Dict]) -> Dict:\n",
        "    \"\"\"Generate a progress note for an encounter.\"\"\"\n",
        "    note_id = f\"PROG-{uuid.uuid4().hex[:8].upper()}\"\n",
        "    \n",
        "    # Generate HPI\n",
        "    hpi = self._generate_hpi(patient, encounter, diagnoses)\n",
        "    \n",
        "    # Generate physical exam\n",
        "    physical_exam = self._generate_physical_exam()\n",
        "    \n",
        "    # Get assessment and plan\n",
        "    assessment_plan = self._generate_assessment_plan(diagnoses)\n",
        "    \n",
        "    # Format DOB as MM/DD/YYYY\n",
        "    if isinstance(patient['date_of_birth'], str):\n",
        "        dob = datetime.strptime(patient['date_of_birth'], '%Y-%m-%d').strftime('%m/%d/%Y')\n",
        "    else:\n",
        "        dob = patient['date_of_birth'].strftime('%m/%d/%Y')\n",
        "    \n",
        "    note_content = f\"\"\"PROGRESS NOTE\n",
        "    \n",
        "Date of Service: {encounter['encounter_date'].strftime('%Y-%m-%d %H:%M')}\n",
        "Patient: {patient['first_name']} {patient['last_name']}\n",
        "MRN: {patient['mrn']}\n",
        "DOB: {dob}\n",
        "\n",
        "CHIEF COMPLAINT:\n",
        "{encounter.get('chief_complaint', 'Follow-up visit')}\n",
        "\n",
        "HISTORY OF PRESENT ILLNESS:\n",
        "{hpi}\n",
        "\n",
        "PHYSICAL EXAMINATION:\n",
        "{physical_exam}\n",
        "\n",
        "ASSESSMENT AND PLAN:\n",
        "{assessment_plan}\n",
        "\n",
        "Provider: {encounter['attending_physician']}\n",
        "Date: {encounter['encounter_date'].strftime('%Y-%m-%d')}\n",
        "\"\"\"\n",
        "    \n",
        "    return {\n",
        "        'note_id': note_id,\n",
        "        'encounter_id': encounter['encounter_id'],\n",
        "        'patient_id': patient['patient_id'],\n",
        "        'note_type': 'Progress Note',\n",
        "        'note_date': encounter['encounter_date'],\n",
        "        'author': encounter['attending_physician'],\n",
        "        'note_content': note_content,\n",
        "        'created_date': encounter['encounter_date'],\n",
        "        'updated_date': datetime.now()\n",
        "    }\n",
        "\n",
        "def generate_nursing_note(self, patient: Dict, encounter: Dict) -> Dict:\n",
        "    \"\"\"Generate a nursing note.\"\"\"\n",
        "    note_id = f\"NURS-{uuid.uuid4().hex[:8].upper()}\"\n",
        "    \n",
        "    activities = random.choice([\n",
        "        'Patient resting comfortably in bed',\n",
        "        'Patient ambulating in hallway with assistance',\n",
        "        'Patient playing in playroom',\n",
        "        'Patient watching TV with parent at bedside'\n",
        "    ])\n",
        "    \n",
        "    intake_output = f\"PO intake: {random.randint(200, 800)}mL\"\n",
        "    \n",
        "    parent_teaching = random.choice([\n",
        "        'Medication administration reviewed with parents',\n",
        "        'Discharge instructions discussed',\n",
        "        'Home care instructions provided',\n",
        "        'Signs and symptoms to watch for reviewed'\n",
        "    ])\n",
        "    \n",
        "    # Format DOB as MM/DD/YYYY\n",
        "    if isinstance(patient['date_of_birth'], str):\n",
        "        dob = datetime.strptime(patient['date_of_birth'], '%Y-%m-%d').strftime('%m/%d/%Y')\n",
        "    else:\n",
        "        dob = patient['date_of_birth'].strftime('%m/%d/%Y')\n",
        "    \n",
        "    note_content = f\"\"\"NURSING NOTE\n",
        "\n",
        "Date/Time: {encounter['encounter_date'].strftime('%Y-%m-%d %H:%M')}\n",
        "Patient: {patient['first_name']} {patient['last_name']}\n",
        "MRN: {patient['mrn']}\n",
        "DOB: {dob}\n",
        "\n",
        "SUBJECTIVE:\n",
        "Patient {random.choice(['denies', 'reports minimal', 'reports mild'])} pain. \n",
        "Parent at bedside, involved in care.\n",
        "\n",
        "OBJECTIVE:\n",
        "Vital signs stable and within normal limits for age.\n",
        "{activities}\n",
        "{intake_output}\n",
        "\n",
        "ASSESSMENT:\n",
        "Patient stable, tolerating treatment well.\n",
        "\n",
        "PLAN:\n",
        "Continue current plan of care.\n",
        "{parent_teaching}\n",
        "\n",
        "Nurse: RN {self.fake.last_name()}\n",
        "\"\"\"\n",
        "    \n",
        "    return {\n",
        "        'note_id': note_id,\n",
        "        'encounter_id': encounter['encounter_id'],\n",
        "        'patient_id': patient['patient_id'],\n",
        "        'note_type': 'Nursing Note',\n",
        "        'note_date': encounter['encounter_date'],\n",
        "        'author': f\"RN {self.fake.last_name()}\",\n",
        "        'note_content': note_content,\n",
        "        'created_date': encounter['encounter_date'],\n",
        "        'updated_date': datetime.now()\n",
        "    }\n",
        "\n",
        "def generate_discharge_summary(self, patient: Dict, encounter: Dict, \n",
        "                             diagnoses: List[Dict], medications: List[Dict]) -> Dict:\n",
        "    \"\"\"Generate a discharge summary.\"\"\"\n",
        "    note_id = f\"DSUM-{uuid.uuid4().hex[:8].upper()}\"\n",
        "    \n",
        "    # Get primary diagnosis\n",
        "    primary_dx = diagnoses[0] if diagnoses else {'description': 'Observation', 'icd10_code': 'Z03.89'}\n",
        "    \n",
        "    # Generate hospital course\n",
        "    hospital_course = self._generate_hospital_course(patient, encounter, diagnoses)\n",
        "    \n",
        "    # Generate discharge medications list\n",
        "    discharge_meds = self._format_discharge_medications(medications)\n",
        "    \n",
        "    # Format DOB as MM/DD/YYYY\n",
        "    if isinstance(patient['date_of_birth'], str):\n",
        "        dob = datetime.strptime(patient['date_of_birth'], '%Y-%m-%d').strftime('%m/%d/%Y')\n",
        "    else:\n",
        "        dob = patient['date_of_birth'].strftime('%m/%d/%Y')\n",
        "    \n",
        "    note_content = f\"\"\"DISCHARGE SUMMARY\n",
        "\n",
        "Admission Date: {encounter['admission_date'].strftime('%Y-%m-%d')}\n",
        "Discharge Date: {encounter.get('discharge_date', encounter['admission_date']).strftime('%Y-%m-%d')}\n",
        "Length of Stay: {encounter.get('length_of_stay', 1)} days\n",
        "\n",
        "Patient: {patient['first_name']} {patient['last_name']}\n",
        "MRN: {patient['mrn']}\n",
        "DOB: {dob}\n",
        "\n",
        "DISCHARGE DIAGNOSES:\n",
        "Primary: {primary_dx['description']} ({primary_dx['icd10_code']})\n",
        "{self._format_secondary_diagnoses(diagnoses[1:])}\n",
        "\n",
        "HOSPITAL COURSE:\n",
        "{hospital_course}\n",
        "\n",
        "DISCHARGE MEDICATIONS:\n",
        "{discharge_meds}\n",
        "\n",
        "DISCHARGE INSTRUCTIONS:\n",
        "1. Follow up with primary care physician in 3-5 days\n",
        "2. Return to ED if fever >101Â°F, worsening symptoms, or concerns\n",
        "3. Continue medications as prescribed\n",
        "4. Activity as tolerated\n",
        "\n",
        "DISCHARGE CONDITION: Stable\n",
        "DISCHARGE DISPOSITION: Home with family\n",
        "\n",
        "Attending Physician: {encounter['attending_physician']}\n",
        "\"\"\"\n",
        "    \n",
        "    return {\n",
        "        'note_id': note_id,\n",
        "        'encounter_id': encounter['encounter_id'],\n",
        "        'patient_id': patient['patient_id'],\n",
        "        'note_type': 'Discharge Summary',\n",
        "        'note_date': encounter.get('discharge_date', encounter['encounter_date']),\n",
        "        'author': encounter['attending_physician'],\n",
        "        'note_content': note_content,\n",
        "        'created_date': encounter['encounter_date'],\n",
        "        'updated_date': datetime.now()\n",
        "    }\n",
        "\n",
        "def generate_consultation_note(self, patient: Dict, encounter: Dict, \n",
        "                             specialty: str, diagnoses: List[Dict]) -> Dict:\n",
        "    \"\"\"Generate a specialty consultation note.\"\"\"\n",
        "    note_id = f\"CONS-{uuid.uuid4().hex[:8].upper()}\"\n",
        "    \n",
        "    reason_for_consult = self._get_consult_reason(specialty, diagnoses)\n",
        "    recommendations = self._get_specialty_recommendations(specialty, patient['age'])\n",
        "    \n",
        "    # Format DOB as MM/DD/YYYY\n",
        "    if isinstance(patient['date_of_birth'], str):\n",
        "        dob = datetime.strptime(patient['date_of_birth'], '%Y-%m-%d').strftime('%m/%d/%Y')\n",
        "    else:\n",
        "        dob = patient['date_of_birth'].strftime('%m/%d/%Y')\n",
        "    \n",
        "    note_content = f\"\"\"{specialty.upper()} CONSULTATION NOTE\n",
        "\n",
        "Date of Consultation: {encounter['encounter_date'].strftime('%Y-%m-%d')}\n",
        "Patient: {patient['first_name']} {patient['last_name']}\n",
        "MRN: {patient['mrn']}\n",
        "DOB: {dob}\n",
        "\n",
        "REASON FOR CONSULTATION:\n",
        "{reason_for_consult}\n",
        "\n",
        "HISTORY OF PRESENT ILLNESS:\n",
        "{self._generate_hpi(patient, encounter, diagnoses)}\n",
        "\n",
        "PAST MEDICAL HISTORY:\n",
        "{self._generate_pmh(patient['age'])}\n",
        "\n",
        "PHYSICAL EXAMINATION:\n",
        "{self._generate_focused_exam(specialty)}\n",
        "\n",
        "ASSESSMENT:\n",
        "Based on history and examination, {self._generate_specialty_assessment(specialty, diagnoses)}\n",
        "\n",
        "RECOMMENDATIONS:\n",
        "{recommendations}\n",
        "\n",
        "Thank you for this interesting consultation.\n",
        "\n",
        "{specialty} Consultant: Dr. {self.fake.last_name()}\n",
        "\"\"\"\n",
        "    \n",
        "    return {\n",
        "        'note_id': note_id,\n",
        "        'encounter_id': encounter['encounter_id'],\n",
        "        'patient_id': patient['patient_id'],\n",
        "        'note_type': 'Consultation Note',\n",
        "        'note_date': encounter['encounter_date'],\n",
        "        'author': f\"Dr. {self.fake.last_name()}\",\n",
        "        'note_content': note_content,\n",
        "        'created_date': encounter['encounter_date'],\n",
        "        'updated_date': datetime.now()\n",
        "    }\n",
        "\n",
        "def generate_radiology_report(self, patient: Dict, encounter: Dict, study_type: str) -> Dict:\n",
        "    \"\"\"Generate a radiology report.\"\"\"\n",
        "    note_id = f\"RAD-{uuid.uuid4().hex[:8].upper()}\"\n",
        "    \n",
        "    # Get appropriate findings for study type\n",
        "    findings = self.radiology_findings.get(study_type, ['No acute findings'])\n",
        "    selected_findings = random.sample(findings, min(3, len(findings)))\n",
        "    \n",
        "    # Determine if normal or abnormal\n",
        "    is_normal = random.random() < 0.7  # 70% normal studies\n",
        "    \n",
        "    if is_normal:\n",
        "        impression = \"No acute pathology identified.\"\n",
        "    else:\n",
        "        impression = self._generate_abnormal_impression(study_type, patient['age'])\n",
        "    \n",
        "    # Format DOB as MM/DD/YYYY\n",
        "    if isinstance(patient['date_of_birth'], str):\n",
        "        dob = datetime.strptime(patient['date_of_birth'], '%Y-%m-%d').strftime('%m/%d/%Y')\n",
        "    else:\n",
        "        dob = patient['date_of_birth'].strftime('%m/%d/%Y')\n",
        "    \n",
        "    note_content = f\"\"\"RADIOLOGY REPORT\n",
        "\n",
        "Study: {study_type.replace('_', ' ').upper()}\n",
        "Date: {encounter['encounter_date'].strftime('%Y-%m-%d %H:%M')}\n",
        "\n",
        "Patient: {patient['first_name']} {patient['last_name']}\n",
        "MRN: {patient['mrn']}\n",
        "DOB: {dob}\n",
        "\n",
        "CLINICAL HISTORY:\n",
        "{encounter.get('chief_complaint', 'Evaluate for pathology')}\n",
        "\n",
        "TECHNIQUE:\n",
        "Standard {study_type.replace('_', ' ')} protocol was performed.\n",
        "\n",
        "FINDINGS:\n",
        "{self._format_findings(selected_findings)}\n",
        "\n",
        "IMPRESSION:\n",
        "{impression}\n",
        "\n",
        "Radiologist: Dr. {self.fake.last_name()}, MD\n",
        "Electronically signed on {datetime.now().strftime('%Y-%m-%d %H:%M')}\n",
        "\"\"\"\n",
        "    \n",
        "    return {\n",
        "        'note_id': note_id,\n",
        "        'encounter_id': encounter['encounter_id'],\n",
        "        'patient_id': patient['patient_id'],\n",
        "        'note_type': 'Radiology Report',\n",
        "        'note_date': encounter['encounter_date'],\n",
        "        'author': f\"Dr. {self.fake.last_name()}\",\n",
        "        'note_content': note_content,\n",
        "        'created_date': encounter['encounter_date'],\n",
        "        'updated_date': datetime.now()\n",
        "    }\n",
        "\n",
        "# Add all methods to ClinicalNotesGenerator\n",
        "ClinicalNotesGenerator.generate_progress_note = generate_progress_note\n",
        "ClinicalNotesGenerator.generate_nursing_note = generate_nursing_note\n",
        "ClinicalNotesGenerator.generate_discharge_summary = generate_discharge_summary\n",
        "ClinicalNotesGenerator.generate_consultation_note = generate_consultation_note\n",
        "ClinicalNotesGenerator.generate_radiology_report = generate_radiology_report\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Helper methods for ClinicalNotesGenerator\n",
        "\n",
        "def _generate_hpi(self, patient: Dict, encounter: Dict, diagnoses: List[Dict]) -> str:\n",
        "    \"\"\"Generate history of present illness.\"\"\"\n",
        "    age_str = f\"{patient['age']}-year-old\"\n",
        "    gender_str = \"male\" if patient['gender'] == 'M' else \"female\"\n",
        "    \n",
        "    # Generate symptom duration\n",
        "    duration = random.choice(['1 day', '2 days', '3 days', '1 week', '2 weeks'])\n",
        "    \n",
        "    # Generate associated symptoms\n",
        "    symptoms = random.sample(self.pediatric_symptoms, random.randint(2, 4))\n",
        "    \n",
        "    hpi = f\"This is a {age_str} {gender_str} who presents with {encounter.get('chief_complaint', 'symptoms')} \"\n",
        "    hpi += f\"for the past {duration}. \"\n",
        "    \n",
        "    if symptoms:\n",
        "        hpi += f\"Associated symptoms include {', '.join(symptoms[:-1])}, and {symptoms[-1]}. \"\n",
        "    \n",
        "    # Add relevant negatives\n",
        "    hpi += f\"Patient denies {random.choice(['chest pain', 'shortness of breath', 'syncope'])}. \"\n",
        "    \n",
        "    return hpi\n",
        "\n",
        "def _generate_physical_exam(self) -> str:\n",
        "    \"\"\"Generate a complete physical examination.\"\"\"\n",
        "    exam_sections = []\n",
        "    \n",
        "    for system, findings in self.physical_exam_findings.items():\n",
        "        finding = random.choice(findings)\n",
        "        if system == 'general':\n",
        "            exam_sections.append(f\"GENERAL: Patient is {finding}\")\n",
        "        elif system == 'vital_signs':\n",
        "            exam_sections.append(f\"VITAL SIGNS: {finding}\")\n",
        "        else:\n",
        "            exam_sections.append(f\"{system.upper()}: {finding.capitalize()}\")\n",
        "    \n",
        "    return '\\n'.join(exam_sections)\n",
        "\n",
        "def _generate_assessment_plan(self, diagnoses: List[Dict]) -> str:\n",
        "    \"\"\"Generate assessment and plan based on diagnoses.\"\"\"\n",
        "    if not diagnoses:\n",
        "        return \"1. Well child visit\\n   - Continue routine care\\n   - Follow up as scheduled\"\n",
        "    \n",
        "    assessment_plan = \"\"\n",
        "    for i, dx in enumerate(diagnoses[:3], 1):  # Limit to top 3 diagnoses\n",
        "        if dx['icd10_code'] in self.assessment_plans:\n",
        "            ap = self.assessment_plans[dx['icd10_code']]\n",
        "            assessment_plan += f\"{i}. {ap['assessment']}\\n\"\n",
        "            for plan_item in ap['plan']:\n",
        "                assessment_plan += f\"   - {plan_item}\\n\"\n",
        "        else:\n",
        "            assessment_plan += f\"{i}. {dx['description']}\\n\"\n",
        "            assessment_plan += f\"   - Monitor symptoms\\n   - Follow up as needed\\n\"\n",
        "    \n",
        "    return assessment_plan\n",
        "\n",
        "def _generate_hospital_course(self, patient: Dict, encounter: Dict, diagnoses: List[Dict]) -> str:\n",
        "    \"\"\"Generate hospital course narrative.\"\"\"\n",
        "    age_str = f\"{patient['age']}-year-old\"\n",
        "    gender_str = \"male\" if patient['gender'] == 'M' else \"female\"\n",
        "    \n",
        "    primary_dx = diagnoses[0]['description'] if diagnoses else 'observation'\n",
        "    \n",
        "    course = f\"Patient is a {age_str} {gender_str} admitted for {primary_dx}. \"\n",
        "    course += \"Hospital course was uncomplicated. \"\n",
        "    course += \"Patient responded well to treatment with improvement in symptoms. \"\n",
        "    course += \"Vital signs remained stable throughout admission. \"\n",
        "    course += \"Patient tolerated diet and medications without difficulty.\"\n",
        "    \n",
        "    return course\n",
        "\n",
        "def _format_discharge_medications(self, medications: List[Dict]) -> str:\n",
        "    \"\"\"Format medications for discharge summary.\"\"\"\n",
        "    if not medications:\n",
        "        return \"No discharge medications\"\n",
        "    \n",
        "    med_list = []\n",
        "    for i, med in enumerate(medications[:5], 1):  # Limit to 5 medications\n",
        "        med_str = f\"{i}. {med['medication_name']} {med['dosage']} {med['route']} {med['frequency']}\"\n",
        "        med_list.append(med_str)\n",
        "    \n",
        "    return '\\n'.join(med_list)\n",
        "\n",
        "def _format_secondary_diagnoses(self, diagnoses: List[Dict]) -> str:\n",
        "    \"\"\"Format secondary diagnoses.\"\"\"\n",
        "    if not diagnoses:\n",
        "        return \"\"\n",
        "    \n",
        "    secondary = []\n",
        "    for dx in diagnoses[:3]:  # Limit to 3 secondary diagnoses\n",
        "        secondary.append(f\"Secondary: {dx['description']} ({dx['icd10_code']})\")\n",
        "    \n",
        "    return '\\n'.join(secondary)\n",
        "\n",
        "def _get_consult_reason(self, specialty: str, diagnoses: List[Dict]) -> str:\n",
        "    \"\"\"Get reason for consultation based on specialty.\"\"\"\n",
        "    consult_reasons = {\n",
        "        'Cardiology': 'Evaluation of cardiac murmur',\n",
        "        'Neurology': 'Evaluation of seizure disorder',\n",
        "        'Pulmonology': 'Management of asthma',\n",
        "        'Gastroenterology': 'Evaluation of chronic abdominal pain',\n",
        "        'Endocrinology': 'Management of Type 1 diabetes',\n",
        "        'Nephrology': 'Evaluation of proteinuria',\n",
        "        'Rheumatology': 'Evaluation of joint pain',\n",
        "        'Dermatology': 'Evaluation of chronic rash',\n",
        "        'Psychiatry': 'Evaluation of mood disorder'\n",
        "    }\n",
        "    \n",
        "    return consult_reasons.get(specialty, f\"{specialty} evaluation requested\")\n",
        "\n",
        "def _get_specialty_recommendations(self, specialty: str, age: int) -> str:\n",
        "    \"\"\"Get specialty-specific recommendations.\"\"\"\n",
        "    base_recs = [\n",
        "        \"1. Will follow in clinic\",\n",
        "        \"2. Additional testing as outlined above\",\n",
        "        \"3. Please continue current management\"\n",
        "    ]\n",
        "    \n",
        "    specialty_recs = {\n",
        "        'Cardiology': [\"Consider echocardiogram\", \"EKG in AM\"],\n",
        "        'Neurology': [\"EEG to be scheduled\", \"Consider MRI brain\"],\n",
        "        'Pulmonology': [\"Pulmonary function tests\", \"Consider controller therapy\"],\n",
        "        'Endocrinology': [\"Check HbA1c\", \"Nutrition counseling\"]\n",
        "    }\n",
        "    \n",
        "    recs = base_recs.copy()\n",
        "    if specialty in specialty_recs:\n",
        "        recs.extend([f\"{i+4}. {rec}\" for i, rec in enumerate(specialty_recs[specialty])])\n",
        "    \n",
        "    return '\\n'.join(recs)\n",
        "\n",
        "def _generate_pmh(self, age: int) -> str:\n",
        "    \"\"\"Generate past medical history.\"\"\"\n",
        "    if age < 2:\n",
        "        return \"Born full term via normal vaginal delivery. No complications.\"\n",
        "    elif age < 10:\n",
        "        return \"Previously healthy child with normal development.\"\n",
        "    else:\n",
        "        return \"No significant past medical history.\"\n",
        "\n",
        "def _generate_focused_exam(self, specialty: str) -> str:\n",
        "    \"\"\"Generate specialty-focused examination.\"\"\"\n",
        "    if specialty == 'Cardiology':\n",
        "        return \"Heart: Regular rate and rhythm, no murmurs, rubs, or gallops. Good perfusion.\"\n",
        "    elif specialty == 'Neurology':\n",
        "        return \"Neuro: Alert and oriented, cranial nerves II-XII intact, normal tone and strength.\"\n",
        "    elif specialty == 'Pulmonology':\n",
        "        return \"Lungs: Clear to auscultation bilaterally, no wheezes or rales, good air movement.\"\n",
        "    else:\n",
        "        return self._generate_physical_exam()\n",
        "\n",
        "def _generate_specialty_assessment(self, specialty: str, diagnoses: List[Dict]) -> str:\n",
        "    \"\"\"Generate specialty-specific assessment.\"\"\"\n",
        "    if diagnoses and diagnoses[0]['description']:\n",
        "        return f\"findings are consistent with {diagnoses[0]['description']}\"\n",
        "    else:\n",
        "        return \"no acute pathology identified at this time\"\n",
        "\n",
        "def _generate_abnormal_impression(self, study_type: str, age: int) -> str:\n",
        "    \"\"\"Generate abnormal radiology impression.\"\"\"\n",
        "    abnormal_findings = {\n",
        "        'chest_xray': [\n",
        "            'Right lower lobe pneumonia',\n",
        "            'Mild peribronchial thickening consistent with viral illness',\n",
        "            'Small pleural effusion'\n",
        "        ],\n",
        "        'abdominal_xray': [\n",
        "            'Moderate stool burden',\n",
        "            'Nonspecific bowel gas pattern',\n",
        "            'No evidence of obstruction'\n",
        "        ],\n",
        "        'brain_ct': [\n",
        "            'No acute intracranial abnormality',\n",
        "            'Mild sinusitis',\n",
        "            'Small amount of fluid in mastoid air cells'\n",
        "        ]\n",
        "    }\n",
        "    \n",
        "    findings = abnormal_findings.get(study_type, ['Findings as above'])\n",
        "    return random.choice(findings)\n",
        "\n",
        "def _format_findings(self, findings: List[str]) -> str:\n",
        "    \"\"\"Format radiology findings into numbered list.\"\"\"\n",
        "    formatted = []\n",
        "    for i, finding in enumerate(findings, 1):\n",
        "        formatted.append(f\"{i}. {finding.capitalize()}\")\n",
        "    return '\\n'.join(formatted)\n",
        "\n",
        "# Add all helper methods to ClinicalNotesGenerator\n",
        "ClinicalNotesGenerator._generate_hpi = _generate_hpi\n",
        "ClinicalNotesGenerator._generate_physical_exam = _generate_physical_exam\n",
        "ClinicalNotesGenerator._generate_assessment_plan = _generate_assessment_plan\n",
        "ClinicalNotesGenerator._generate_hospital_course = _generate_hospital_course\n",
        "ClinicalNotesGenerator._format_discharge_medications = _format_discharge_medications\n",
        "ClinicalNotesGenerator._format_secondary_diagnoses = _format_secondary_diagnoses\n",
        "ClinicalNotesGenerator._get_consult_reason = _get_consult_reason\n",
        "ClinicalNotesGenerator._get_specialty_recommendations = _get_specialty_recommendations\n",
        "ClinicalNotesGenerator._generate_pmh = _generate_pmh\n",
        "ClinicalNotesGenerator._generate_focused_exam = _generate_focused_exam\n",
        "ClinicalNotesGenerator._generate_specialty_assessment = _generate_specialty_assessment\n",
        "ClinicalNotesGenerator._generate_abnormal_impression = _generate_abnormal_impression\n",
        "ClinicalNotesGenerator._format_findings = _format_findings\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# TCHDataGenerationOrchestrator class\n",
        "class TCHDataGenerationOrchestrator:\n",
        "    \"\"\"Orchestrates the generation of all TCH PoC data.\"\"\"\n",
        "    \n",
        "    def __init__(self, output_dir: str = \"/tmp/tch_data_generation\", seed: int = 42, compress_files: bool = False):\n",
        "        \"\"\"Initialize the data generation orchestrator.\"\"\"\n",
        "        self.output_dir = Path(output_dir)\n",
        "        self.output_dir.mkdir(parents=True, exist_ok=True)\n",
        "        self.compress_files = compress_files\n",
        "        \n",
        "        # Create subdirectories for different data types\n",
        "        self.structured_dir = self.output_dir / \"structured\"\n",
        "        self.unstructured_dir = self.output_dir / \"unstructured\"\n",
        "        self.structured_dir.mkdir(exist_ok=True)\n",
        "        self.unstructured_dir.mkdir(exist_ok=True)\n",
        "        \n",
        "        # Initialize generators\n",
        "        self.pediatric_generator = PediatricDataGenerator(seed=seed)\n",
        "        self.notes_generator = ClinicalNotesGenerator(seed=seed)\n",
        "        \n",
        "        compression_note = \" (with gzip compression)\" if compress_files else \"\"\n",
        "        print(f\"Data generation output directory: {self.output_dir.absolute()}{compression_note}\")\n",
        "    \n",
        "    def _save_to_csv(self, data: List[Dict], filename: str):\n",
        "        \"\"\"Save data to CSV file with proper handling of datetime objects.\"\"\"\n",
        "        if not data:\n",
        "            print(f\"   Warning: No data to save for {filename}\")\n",
        "            return\n",
        "        \n",
        "        # Add .gz extension if compression is enabled\n",
        "        if self.compress_files:\n",
        "            if not filename.endswith('.gz'):\n",
        "                filename = filename + '.gz'\n",
        "        \n",
        "        filepath = self.structured_dir / filename\n",
        "        \n",
        "        # Convert data to DataFrame for better CSV handling\n",
        "        df = pd.DataFrame(data)\n",
        "        \n",
        "        # Convert datetime columns to strings\n",
        "        for col in df.columns:\n",
        "            if df[col].dtype == 'object':\n",
        "                # Check if column contains datetime objects\n",
        "                sample_val = df[col].dropna().iloc[0] if not df[col].dropna().empty else None\n",
        "                if isinstance(sample_val, (datetime, pd.Timestamp)):\n",
        "                    df[col] = df[col].dt.strftime('%Y-%m-%d %H:%M:%S')\n",
        "                elif hasattr(sample_val, 'strftime'):  # date objects\n",
        "                    df[col] = df[col].apply(lambda x: x.strftime('%Y-%m-%d') if pd.notna(x) else None)\n",
        "        \n",
        "        # Save with or without compression\n",
        "        if self.compress_files:\n",
        "            with gzip.open(filepath, 'wt', encoding='utf-8') as f:\n",
        "                df.to_csv(f, index=False, quoting=csv.QUOTE_NONNUMERIC)\n",
        "        else:\n",
        "            df.to_csv(filepath, index=False, quoting=csv.QUOTE_NONNUMERIC)\n",
        "        \n",
        "        file_size = filepath.stat().st_size / (1024 * 1024)  # Size in MB\n",
        "        compression_note = \" (compressed)\" if self.compress_files else \"\"\n",
        "        print(f\"   Saved {len(data):,} records to {filename} ({file_size:.1f} MB){compression_note}\")\n",
        "    \n",
        "    def _save_text_file(self, content: str, filename: str, subdir: str = \"\"):\n",
        "        \"\"\"Save text content to file.\"\"\"\n",
        "        if subdir:\n",
        "            target_dir = self.unstructured_dir / subdir\n",
        "            target_dir.mkdir(exist_ok=True)\n",
        "        else:\n",
        "            target_dir = self.unstructured_dir\n",
        "        \n",
        "        # Add .gz extension if compression is enabled\n",
        "        if self.compress_files:\n",
        "            if not filename.endswith('.gz'):\n",
        "                filename = filename + '.gz'\n",
        "        \n",
        "        filepath = target_dir / filename\n",
        "        \n",
        "        # Save with or without compression\n",
        "        if self.compress_files:\n",
        "            with gzip.open(filepath, 'wt', encoding='utf-8') as f:\n",
        "                f.write(content)\n",
        "        else:\n",
        "            with open(filepath, 'w', encoding='utf-8') as f:\n",
        "                f.write(content)\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Data generation methods for TCHDataGenerationOrchestrator\n",
        "\n",
        "def _generate_imaging_studies(self, encounters: List[Dict], patients: List[Dict]) -> List[Dict]:\n",
        "    \"\"\"Generate imaging study records.\"\"\"\n",
        "    imaging_studies = []\n",
        "    study_id = 1\n",
        "    \n",
        "    # Create patient lookup\n",
        "    patient_lookup = {p['patient_id']: p for p in patients}\n",
        "    \n",
        "    # Common pediatric imaging studies\n",
        "    study_types = [\n",
        "        ('chest_xray', 'Chest X-ray', 0.15),\n",
        "        ('abdominal_xray', 'Abdominal X-ray', 0.08),\n",
        "        ('brain_mri', 'Brain MRI', 0.03),\n",
        "        ('brain_ct', 'Brain CT', 0.05),\n",
        "        ('ultrasound_abdomen', 'Abdominal Ultrasound', 0.06),\n",
        "        ('echo', 'Echocardiogram', 0.04)\n",
        "    ]\n",
        "    \n",
        "    for encounter in encounters:\n",
        "        patient = patient_lookup[encounter['patient_id']]\n",
        "        \n",
        "        # Determine if imaging is needed based on encounter type and department\n",
        "        imaging_probability = 0.1  # Base 10% chance\n",
        "        \n",
        "        if encounter['encounter_type'] == 'Emergency':\n",
        "            imaging_probability = 0.25\n",
        "        elif encounter['department'] in ['Pediatric ICU', 'NICU']:\n",
        "            imaging_probability = 0.4\n",
        "        elif encounter['department'] in ['Cardiology', 'Pulmonology', 'Neurology']:\n",
        "            imaging_probability = 0.3\n",
        "        \n",
        "        if random.random() < imaging_probability:\n",
        "            # Select appropriate study type\n",
        "            study_code, study_name, _ = random.choice(study_types)\n",
        "            \n",
        "            imaging_study = {\n",
        "                'imaging_study_id': f\"IMG-{study_id:08d}\",\n",
        "                'encounter_id': encounter['encounter_id'],\n",
        "                'patient_id': encounter['patient_id'],\n",
        "                'study_type': study_code,\n",
        "                'study_name': study_name,\n",
        "                'study_date': encounter['encounter_date'] + timedelta(hours=random.randint(1, 24)),\n",
        "                'ordering_provider': encounter['attending_physician'],\n",
        "                'performing_department': 'Radiology',\n",
        "                'study_status': random.choice(['Completed', 'Preliminary', 'Final']),\n",
        "                'modality': self._get_modality_for_study(study_code),\n",
        "                'body_part': self._get_body_part_for_study(study_code),\n",
        "                'created_date': encounter['encounter_date'],\n",
        "                'updated_date': datetime.now()\n",
        "            }\n",
        "            imaging_studies.append(imaging_study)\n",
        "            study_id += 1\n",
        "    \n",
        "    return imaging_studies\n",
        "\n",
        "def _get_modality_for_study(self, study_type: str) -> str:\n",
        "    \"\"\"Get imaging modality for study type.\"\"\"\n",
        "    modality_map = {\n",
        "        'chest_xray': 'XR',\n",
        "        'abdominal_xray': 'XR',\n",
        "        'brain_mri': 'MR',\n",
        "        'brain_ct': 'CT',\n",
        "        'ultrasound_abdomen': 'US',\n",
        "        'echo': 'US'\n",
        "    }\n",
        "    return modality_map.get(study_type, 'XR')\n",
        "\n",
        "def _get_body_part_for_study(self, study_type: str) -> str:\n",
        "    \"\"\"Get body part for study type.\"\"\"\n",
        "    body_part_map = {\n",
        "        'chest_xray': 'Chest',\n",
        "        'abdominal_xray': 'Abdomen',\n",
        "        'brain_mri': 'Brain',\n",
        "        'brain_ct': 'Brain',\n",
        "        'ultrasound_abdomen': 'Abdomen',\n",
        "        'echo': 'Heart'\n",
        "    }\n",
        "    return body_part_map.get(study_type, 'Chest')\n",
        "\n",
        "def _generate_providers(self) -> List[Dict]:\n",
        "    \"\"\"Generate provider/physician data.\"\"\"\n",
        "    providers = []\n",
        "    \n",
        "    # Specialties at TCH\n",
        "    specialties = [\n",
        "        'General Pediatrics', 'Emergency Medicine', 'Pediatric Critical Care',\n",
        "        'Neonatology', 'Cardiology', 'Neurology', 'Oncology', 'Orthopedics',\n",
        "        'Pulmonology', 'Gastroenterology', 'Endocrinology', 'Nephrology',\n",
        "        'Rheumatology', 'Dermatology', 'Ophthalmology', 'ENT', 'Psychiatry',\n",
        "        'Adolescent Medicine', 'Radiology', 'Pathology', 'Anesthesiology'\n",
        "    ]\n",
        "    \n",
        "    provider_id = 1\n",
        "    for specialty in specialties:\n",
        "        # Generate 10-20 providers per specialty\n",
        "        num_providers = random.randint(10, 20)\n",
        "        for _ in range(num_providers):\n",
        "            provider = {\n",
        "                'provider_id': f\"PROV-{provider_id:06d}\",\n",
        "                'npi': f\"{random.randint(1000000000, 9999999999)}\",\n",
        "                'first_name': self.pediatric_generator.fake.first_name(),\n",
        "                'last_name': self.pediatric_generator.fake.last_name(),\n",
        "                'specialty': specialty,\n",
        "                'department': specialty,\n",
        "                'credentials': random.choice(['MD', 'DO', 'MD, PhD']),\n",
        "                'status': random.choice(['Active', 'Active', 'Active', 'Inactive']),  # Mostly active\n",
        "                'hire_date': self.pediatric_generator.fake.date_between(start_date='-20y', end_date='-1y'),\n",
        "                'created_date': datetime.now() - timedelta(days=random.randint(30, 1000)),\n",
        "                'updated_date': datetime.now()\n",
        "            }\n",
        "            providers.append(provider)\n",
        "            provider_id += 1\n",
        "    \n",
        "    return providers\n",
        "\n",
        "def _generate_departments(self) -> List[Dict]:\n",
        "    \"\"\"Generate department/service line data.\"\"\"\n",
        "    departments = []\n",
        "    \n",
        "    dept_info = [\n",
        "        ('Emergency Department', 'ED', 'Emergency Medicine'),\n",
        "        ('Pediatric ICU', 'PICU', 'Critical Care'),\n",
        "        ('NICU', 'NICU', 'Neonatology'),\n",
        "        ('General Pediatrics', 'PEDS', 'Ambulatory'),\n",
        "        ('Cardiology', 'CARDS', 'Specialty'),\n",
        "        ('Neurology', 'NEURO', 'Specialty'),\n",
        "        ('Oncology', 'ONCO', 'Specialty'),\n",
        "        ('Orthopedics', 'ORTHO', 'Specialty'),\n",
        "        ('Pulmonology', 'PULM', 'Specialty'),\n",
        "        ('Gastroenterology', 'GI', 'Specialty'),\n",
        "        ('Endocrinology', 'ENDO', 'Specialty'),\n",
        "        ('Nephrology', 'NEPHRO', 'Specialty'),\n",
        "        ('Radiology', 'RAD', 'Ancillary'),\n",
        "        ('Laboratory', 'LAB', 'Ancillary'),\n",
        "        ('Pharmacy', 'PHARM', 'Ancillary')\n",
        "    ]\n",
        "    \n",
        "    for i, (name, code, service_line) in enumerate(dept_info, 1):\n",
        "        department = {\n",
        "            'department_id': f\"DEPT-{i:03d}\",\n",
        "            'department_name': name,\n",
        "            'department_code': code,\n",
        "            'service_line': service_line,\n",
        "            'location': random.choice(['Main Campus', 'West Campus', 'The Woodlands']),\n",
        "            'status': 'Active',\n",
        "            'created_date': datetime.now() - timedelta(days=random.randint(100, 2000)),\n",
        "            'updated_date': datetime.now()\n",
        "        }\n",
        "        departments.append(department)\n",
        "    \n",
        "    return departments\n",
        "\n",
        "def _generate_clinical_notes(self, encounters: List[Dict], patients: List[Dict], \n",
        "                           diagnoses: List[Dict], medications: List[Dict]) -> List[Dict]:\n",
        "    \"\"\"Generate clinical notes and documentation.\"\"\"\n",
        "    clinical_notes = []\n",
        "    \n",
        "    # Create lookups for efficient access\n",
        "    patient_lookup = {p['patient_id']: p for p in patients}\n",
        "    encounter_diagnoses = {}\n",
        "    encounter_medications = {}\n",
        "    \n",
        "    for dx in diagnoses:\n",
        "        if dx['encounter_id'] not in encounter_diagnoses:\n",
        "            encounter_diagnoses[dx['encounter_id']] = []\n",
        "        encounter_diagnoses[dx['encounter_id']].append(dx)\n",
        "    \n",
        "    for med in medications:\n",
        "        if med['encounter_id'] not in encounter_medications:\n",
        "            encounter_medications[med['encounter_id']] = []\n",
        "        encounter_medications[med['encounter_id']].append(med)\n",
        "    \n",
        "    # Generate notes for subset of encounters (performance consideration)\n",
        "    sample_encounters = random.sample(encounters, min(len(encounters), 100000))\n",
        "    \n",
        "    for i, encounter in enumerate(sample_encounters):\n",
        "        if i % 10000 == 0:\n",
        "            print(f\"    Generating notes for encounter {i+1:,} of {len(sample_encounters):,}\")\n",
        "        \n",
        "        patient = patient_lookup[encounter['patient_id']]\n",
        "        enc_diagnoses = encounter_diagnoses.get(encounter['encounter_id'], [])\n",
        "        enc_medications = encounter_medications.get(encounter['encounter_id'], [])\n",
        "        \n",
        "        # Generate different types of notes based on encounter\n",
        "        note_types_to_generate = ['progress']\n",
        "        \n",
        "        if encounter['encounter_type'] == 'Inpatient':\n",
        "            note_types_to_generate.extend(['nursing', 'discharge'])\n",
        "        \n",
        "        if encounter['encounter_type'] == 'Emergency':\n",
        "            note_types_to_generate.append('nursing')\n",
        "        \n",
        "        if encounter['department'] in ['Cardiology', 'Neurology', 'Pulmonology']:\n",
        "            note_types_to_generate.append('consultation')\n",
        "        \n",
        "        # Generate each type of note\n",
        "        for note_type in note_types_to_generate:\n",
        "            try:\n",
        "                if note_type == 'progress':\n",
        "                    note = self.notes_generator.generate_progress_note(patient, encounter, enc_diagnoses)\n",
        "                elif note_type == 'nursing':\n",
        "                    note = self.notes_generator.generate_nursing_note(patient, encounter)\n",
        "                elif note_type == 'discharge':\n",
        "                    note = self.notes_generator.generate_discharge_summary(patient, encounter, enc_diagnoses, enc_medications)\n",
        "                elif note_type == 'consultation':\n",
        "                    note = self.notes_generator.generate_consultation_note(patient, encounter, encounter['department'], enc_diagnoses)\n",
        "                \n",
        "                clinical_notes.append(note)\n",
        "                \n",
        "                # Save note content to individual text file\n",
        "                filename = f\"note_{note['note_id']}.txt\"\n",
        "                self._save_text_file(note['note_content'], filename, \"clinical_notes\")\n",
        "                \n",
        "            except Exception as e:\n",
        "                print(f\"    Error generating {note_type} note for encounter {encounter['encounter_id']}: {e}\")\n",
        "                continue\n",
        "    \n",
        "    # Save clinical notes metadata\n",
        "    self._save_to_csv(clinical_notes, 'clinical_notes.csv')\n",
        "    \n",
        "    return clinical_notes\n",
        "\n",
        "def _generate_radiology_reports(self, imaging_studies: List[Dict], patients: List[Dict], \n",
        "                              encounters: List[Dict]) -> List[Dict]:\n",
        "    \"\"\"Generate radiology reports.\"\"\"\n",
        "    radiology_reports = []\n",
        "    \n",
        "    # Create lookups\n",
        "    patient_lookup = {p['patient_id']: p for p in patients}\n",
        "    encounter_lookup = {e['encounter_id']: e for e in encounters}\n",
        "    \n",
        "    for study in imaging_studies:\n",
        "        if study['study_status'] in ['Completed', 'Final']:\n",
        "            try:\n",
        "                patient = patient_lookup[study['patient_id']]\n",
        "                encounter = encounter_lookup[study['encounter_id']]\n",
        "                \n",
        "                report = self.notes_generator.generate_radiology_report(\n",
        "                    patient, encounter, study['study_type']\n",
        "                )\n",
        "                \n",
        "                # Add study-specific information\n",
        "                report['imaging_study_id'] = study['imaging_study_id']\n",
        "                report['study_type'] = study['study_type']\n",
        "                \n",
        "                radiology_reports.append(report)\n",
        "                \n",
        "                # Save report content to text file\n",
        "                filename = f\"radiology_{report['note_id']}.txt\"\n",
        "                self._save_text_file(report['note_content'], filename, \"radiology_reports\")\n",
        "                \n",
        "            except Exception as e:\n",
        "                print(f\"    Error generating radiology report for study {study['imaging_study_id']}: {e}\")\n",
        "                continue\n",
        "    \n",
        "    # Save radiology reports metadata\n",
        "    self._save_to_csv(radiology_reports, 'radiology_reports.csv')\n",
        "    \n",
        "    return radiology_reports\n",
        "\n",
        "def _generate_metadata(self, stats: Dict[str, int], num_patients: int, encounters_per_patient: int):\n",
        "    \"\"\"Generate metadata about the dataset.\"\"\"\n",
        "    metadata = {\n",
        "        'generated_date': datetime.now().isoformat(),\n",
        "        'generator_version': '1.0.0',\n",
        "        'target_patients': num_patients,\n",
        "        'target_encounters_per_patient': encounters_per_patient,\n",
        "        'actual_statistics': stats,\n",
        "        'data_characteristics': {\n",
        "            'age_distribution': 'Pediatric (0-21 years) with higher concentration in younger ages',\n",
        "            'geographic_focus': 'Houston metropolitan area zip codes',\n",
        "            'insurance_mix': 'Realistic pediatric insurance distribution (Medicaid, Commercial, CHIP)',\n",
        "            'condition_prevalence': 'Matches real-world pediatric disease prevalence rates',\n",
        "            'clinical_realism': 'Age-appropriate diagnoses, medications, and vital signs'\n",
        "        },\n",
        "        'file_structure': {\n",
        "            'structured_data': str(self.structured_dir),\n",
        "            'unstructured_data': str(self.unstructured_dir),\n",
        "            'csv_files': list(self.structured_dir.glob(\"*.csv\")),\n",
        "            'text_files': {\n",
        "                'clinical_notes': len(list((self.unstructured_dir / \"clinical_notes\").glob(\"*.txt\"))),\n",
        "                'radiology_reports': len(list((self.unstructured_dir / \"radiology_reports\").glob(\"*.txt\")))\n",
        "            }\n",
        "        }\n",
        "    }\n",
        "    \n",
        "    # Save metadata\n",
        "    metadata_file = self.output_dir / \"dataset_metadata.json\"\n",
        "    with open(metadata_file, 'w') as f:\n",
        "        json.dump(metadata, f, indent=2, default=str)\n",
        "    \n",
        "    print(f\"   Generated metadata file: {metadata_file}\")\n",
        "\n",
        "# Add methods to TCHDataGenerationOrchestrator\n",
        "TCHDataGenerationOrchestrator._generate_imaging_studies = _generate_imaging_studies\n",
        "TCHDataGenerationOrchestrator._get_modality_for_study = _get_modality_for_study\n",
        "TCHDataGenerationOrchestrator._get_body_part_for_study = _get_body_part_for_study\n",
        "TCHDataGenerationOrchestrator._generate_providers = _generate_providers\n",
        "TCHDataGenerationOrchestrator._generate_departments = _generate_departments\n",
        "TCHDataGenerationOrchestrator._generate_clinical_notes = _generate_clinical_notes\n",
        "TCHDataGenerationOrchestrator._generate_radiology_reports = _generate_radiology_reports\n",
        "TCHDataGenerationOrchestrator._generate_metadata = _generate_metadata\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Main generation method for TCHDataGenerationOrchestrator\n",
        "\n",
        "def generate_complete_dataset(self, num_patients: int = 500000, \n",
        "                            encounters_per_patient: int = 5) -> Dict[str, int]:\n",
        "    \"\"\"Generate complete dataset for TCH PoC.\"\"\"\n",
        "    \n",
        "    print(f\"Starting generation of comprehensive TCH dataset...\")\n",
        "    print(f\"Target: {num_patients:,} patients with ~{encounters_per_patient} encounters each\")\n",
        "    print(f\"Expected total encounters: ~{num_patients * encounters_per_patient:,}\")\n",
        "    \n",
        "    stats = {}\n",
        "    \n",
        "    # Generate core structured data\n",
        "    print(\"\\n1. Generating patient demographics...\")\n",
        "    patients = self.pediatric_generator.generate_patient_demographics(num_patients)\n",
        "    self._save_to_csv(patients, 'patients.csv')\n",
        "    stats['patients'] = len(patients)\n",
        "    print(f\"   Generated {len(patients):,} patients\")\n",
        "    \n",
        "    print(\"\\n2. Generating encounters...\")\n",
        "    encounters = self.pediatric_generator.generate_encounters(patients, encounters_per_patient)\n",
        "    self._save_to_csv(encounters, 'encounters.csv')\n",
        "    stats['encounters'] = len(encounters)\n",
        "    print(f\"   Generated {len(encounters):,} encounters\")\n",
        "    \n",
        "    print(\"\\n3. Generating diagnoses...\")\n",
        "    diagnoses = self.pediatric_generator.generate_diagnoses(encounters)\n",
        "    self._save_to_csv(diagnoses, 'diagnoses.csv')\n",
        "    stats['diagnoses'] = len(diagnoses)\n",
        "    print(f\"   Generated {len(diagnoses):,} diagnoses\")\n",
        "    \n",
        "    print(\"\\n4. Generating lab results...\")\n",
        "    lab_results = self.pediatric_generator.generate_lab_results(encounters, patients)\n",
        "    self._save_to_csv(lab_results, 'lab_results.csv')\n",
        "    stats['lab_results'] = len(lab_results)\n",
        "    print(f\"   Generated {len(lab_results):,} lab results\")\n",
        "    \n",
        "    print(\"\\n5. Generating medications...\")\n",
        "    medications = self.pediatric_generator.generate_medications(encounters, diagnoses)\n",
        "    self._save_to_csv(medications, 'medications.csv')\n",
        "    stats['medications'] = len(medications)\n",
        "    print(f\"   Generated {len(medications):,} medications\")\n",
        "    \n",
        "    print(\"\\n6. Generating vital signs...\")\n",
        "    vital_signs = self.pediatric_generator.generate_vital_signs(encounters, patients)\n",
        "    self._save_to_csv(vital_signs, 'vital_signs.csv')\n",
        "    stats['vital_signs'] = len(vital_signs)\n",
        "    print(f\"   Generated {len(vital_signs):,} vital signs records\")\n",
        "    \n",
        "    # Generate additional healthcare data\n",
        "    print(\"\\n7. Generating imaging studies...\")\n",
        "    imaging_studies = self._generate_imaging_studies(encounters, patients)\n",
        "    self._save_to_csv(imaging_studies, 'imaging_studies.csv')\n",
        "    stats['imaging_studies'] = len(imaging_studies)\n",
        "    print(f\"   Generated {len(imaging_studies):,} imaging studies\")\n",
        "    \n",
        "    print(\"\\n8. Generating provider data...\")\n",
        "    providers = self._generate_providers()\n",
        "    self._save_to_csv(providers, 'providers.csv')\n",
        "    stats['providers'] = len(providers)\n",
        "    print(f\"   Generated {len(providers):,} providers\")\n",
        "    \n",
        "    print(\"\\n9. Generating department data...\")\n",
        "    departments = self._generate_departments()\n",
        "    self._save_to_csv(departments, 'departments.csv')\n",
        "    stats['departments'] = len(departments)\n",
        "    print(f\"   Generated {len(departments):,} departments\")\n",
        "    \n",
        "    # Generate unstructured clinical documentation\n",
        "    print(\"\\n10. Generating clinical notes...\")\n",
        "    clinical_notes = self._generate_clinical_notes(encounters, patients, diagnoses, medications)\n",
        "    stats['clinical_notes'] = len(clinical_notes)\n",
        "    print(f\"    Generated {len(clinical_notes):,} clinical notes\")\n",
        "    \n",
        "    print(\"\\n11. Generating radiology reports...\")\n",
        "    radiology_reports = self._generate_radiology_reports(imaging_studies, patients, encounters)\n",
        "    stats['radiology_reports'] = len(radiology_reports)\n",
        "    print(f\"    Generated {len(radiology_reports):,} radiology reports\")\n",
        "    \n",
        "    # Generate summary statistics and metadata\n",
        "    print(\"\\n12. Generating metadata and statistics...\")\n",
        "    self._generate_metadata(stats, num_patients, encounters_per_patient)\n",
        "    \n",
        "    print(f\"\\nâœ… Data generation complete!\")\n",
        "    print(f\"\\nFinal statistics:\")\n",
        "    for category, count in stats.items():\n",
        "        print(f\"   {category}: {count:,}\")\n",
        "    \n",
        "    # Count files (both compressed and uncompressed)\n",
        "    csv_files = list(self.structured_dir.glob(\"*.csv\")) + list(self.structured_dir.glob(\"*.csv.gz\"))\n",
        "    txt_files = list(self.unstructured_dir.glob(\"**/*.txt\")) + list(self.unstructured_dir.glob(\"**/*.txt.gz\"))\n",
        "    total_files = len(csv_files) + len(txt_files)\n",
        "    print(f\"\\nðŸ“ Generated {total_files} data files\")\n",
        "    print(f\"   Structured data: {self.structured_dir}\")\n",
        "    print(f\"   Unstructured data: {self.unstructured_dir}\")\n",
        "    \n",
        "    return stats\n",
        "\n",
        "# Add method to TCHDataGenerationOrchestrator\n",
        "TCHDataGenerationOrchestrator.generate_complete_dataset = generate_complete_dataset\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Main execution: Generate the data\n",
        "print(\"ðŸ¥ Texas Children's Hospital Patient 360 PoC Data Generator\")\n",
        "print(\"=\" * 60)\n",
        "\n",
        "# Initialize orchestrator\n",
        "orchestrator = TCHDataGenerationOrchestrator(\n",
        "    output_dir=str(TEMP_DIR),\n",
        "    seed=42,\n",
        "    compress_files=COMPRESS_FILES\n",
        ")\n",
        "\n",
        "# Generate complete dataset\n",
        "start_time = datetime.now()\n",
        "stats = orchestrator.generate_complete_dataset(\n",
        "    num_patients=NUM_PATIENTS,\n",
        "    encounters_per_patient=ENCOUNTERS_PER_PATIENT\n",
        ")\n",
        "end_time = datetime.now()\n",
        "\n",
        "# Final summary\n",
        "duration = end_time - start_time\n",
        "print(f\"\\nâ±ï¸  Generation completed in {duration}\")\n",
        "print(f\"ðŸ“Š Total data points: {sum(stats.values()):,}\")\n",
        "print(f\"ðŸ’¾ Output directory: {TEMP_DIR.absolute()}\")\n",
        "print(\"\\nðŸŽ‰ TCH Patient 360 PoC dataset generation complete!\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Upload structured data files to Snowflake stage\n",
        "print(\"\\nðŸ“¤ Uploading structured data files to Snowflake stage...\")\n",
        "\n",
        "# List all CSV files\n",
        "csv_files = list(STRUCTURED_DIR.glob(\"*.csv.gz\" if COMPRESS_FILES else \"*.csv\"))\n",
        "print(f\"Found {len(csv_files)} structured data files to upload\")\n",
        "\n",
        "# Upload each file using session.file.put()\n",
        "for csv_file in csv_files:\n",
        "    print(f\"  Uploading {csv_file.name}...\")\n",
        "    \n",
        "    try:\n",
        "        # Upload file to stage\n",
        "        put_result = session.file.put(\n",
        "            str(csv_file), \n",
        "            STRUCTURED_STAGE,\n",
        "            auto_compress=False,  # We're already handling compression\n",
        "            overwrite=True\n",
        "        )\n",
        "        \n",
        "        # Check upload status\n",
        "        for result in put_result:\n",
        "            if result.status == 'UPLOADED':\n",
        "                print(f\"    âœ… {result.source} uploaded successfully ({result.source_size:,} bytes)\")\n",
        "            else:\n",
        "                print(f\"    âš ï¸  {result.source} status: {result.status}\")\n",
        "            \n",
        "    except Exception as e:\n",
        "        print(f\"    âŒ Error uploading {csv_file.name}: {e}\")\n",
        "\n",
        "print(\"âœ… Structured data upload complete\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Upload unstructured data files to Snowflake stage\n",
        "print(\"\\nðŸ“¤ Uploading unstructured data files to Snowflake stage...\")\n",
        "\n",
        "# Upload clinical notes\n",
        "clinical_notes_dir = UNSTRUCTURED_DIR / \"clinical_notes\"\n",
        "if clinical_notes_dir.exists():\n",
        "    notes_files = list(clinical_notes_dir.glob(\"*.txt.gz\" if COMPRESS_FILES else \"*.txt\"))\n",
        "    print(f\"Found {len(notes_files)} clinical note files\")\n",
        "    \n",
        "    if notes_files:\n",
        "        print(\"  Uploading clinical notes...\")\n",
        "        # Upload files in batches for efficiency\n",
        "        batch_size = 100\n",
        "        for i in range(0, len(notes_files), batch_size):\n",
        "            batch = notes_files[i:i+batch_size]\n",
        "            print(f\"    Uploading batch {i//batch_size + 1} ({len(batch)} files)...\")\n",
        "            \n",
        "            for note_file in batch:\n",
        "                try:\n",
        "                    put_result = session.file.put(\n",
        "                        str(note_file),\n",
        "                        f\"{UNSTRUCTURED_STAGE}/clinical_notes/\",\n",
        "                        auto_compress=False,\n",
        "                        overwrite=True\n",
        "                    )\n",
        "                    # Don't print individual file status for large batches\n",
        "                except Exception as e:\n",
        "                    print(f\"      âŒ Error uploading {note_file.name}: {e}\")\n",
        "            \n",
        "            print(f\"    âœ… Batch {i//batch_size + 1} uploaded\")\n",
        "\n",
        "# Upload radiology reports\n",
        "radiology_dir = UNSTRUCTURED_DIR / \"radiology_reports\"\n",
        "if radiology_dir.exists():\n",
        "    radiology_files = list(radiology_dir.glob(\"*.txt.gz\" if COMPRESS_FILES else \"*.txt\"))\n",
        "    print(f\"Found {len(radiology_files)} radiology report files\")\n",
        "    \n",
        "    if radiology_files:\n",
        "        print(\"  Uploading radiology reports...\")\n",
        "        # Upload all radiology reports\n",
        "        for rad_file in radiology_files:\n",
        "            try:\n",
        "                put_result = session.file.put(\n",
        "                    str(rad_file),\n",
        "                    f\"{UNSTRUCTURED_STAGE}/radiology_reports/\",\n",
        "                    auto_compress=False,\n",
        "                    overwrite=True\n",
        "                )\n",
        "            except Exception as e:\n",
        "                print(f\"    âŒ Error uploading {rad_file.name}: {e}\")\n",
        "        \n",
        "        print(\"  âœ… Radiology reports uploaded\")\n",
        "\n",
        "print(\"âœ… Unstructured data upload complete\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Verify uploaded files and provide final status\n",
        "print(\"\\nðŸ“‹ Verifying uploaded files...\")\n",
        "\n",
        "# Check structured data stage\n",
        "print(\"\\nStructured data files:\")\n",
        "list_query = f\"LIST {STRUCTURED_STAGE};\"\n",
        "result = session.sql(list_query).collect()\n",
        "structured_count = len(result)\n",
        "print(f\"  Found {structured_count} files in structured stage\")\n",
        "\n",
        "# Check unstructured data stage\n",
        "print(\"\\nUnstructured data files:\")\n",
        "list_query = f\"LIST {UNSTRUCTURED_STAGE};\"\n",
        "result = session.sql(list_query).collect()\n",
        "unstructured_count = len(result)\n",
        "print(f\"  Found {unstructured_count} files in unstructured stage\")\n",
        "\n",
        "print(f\"\\nâœ… Data generation and upload completed successfully!\")\n",
        "print(f\"\\nðŸ“Š Summary:\")\n",
        "print(f\"  - Generated {NUM_PATIENTS:,} patients\")\n",
        "print(f\"  - Created {structured_count} structured data files\")\n",
        "print(f\"  - Created {unstructured_count} unstructured data files\")\n",
        "print(f\"  - Total generation time: {duration}\")\n",
        "\n",
        "print(f\"\\nðŸŽ¯ Next Steps:\")\n",
        "print(f\"  1. Run the data ingestion SQL scripts to load data into raw tables\")\n",
        "print(f\"  2. Deploy Dynamic Tables to create the conformed layer\")\n",
        "print(f\"  3. Deploy presentation layer views\")\n",
        "print(f\"  4. Setup Cortex Search services\")\n",
        "print(f\"  5. Deploy the Streamlit application\")\n",
        "\n",
        "# Optional: Clean up temporary files\n",
        "# Uncomment the following lines if you want to clean up local files after upload\n",
        "# print(\"\\nðŸ§¹ Cleaning up temporary files...\")\n",
        "# shutil.rmtree(TEMP_DIR)\n",
        "# print(\"âœ… Cleanup complete\")\n"
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": []
    }
  ],
  "metadata": {
    "language_info": {
      "name": "python"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 2
}
